<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[光伏建模（2）——核密度估计实现]]></title>
      <url>%2F2017%2F03%2F17%2F%E5%85%89%E4%BC%8F%E5%BB%BA%E6%A8%A1%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[数据录入 12345678910111213141516171819202122232425262728solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\一月\太阳能测光数据_2010-01-01 - 2010-02-01.xls');solardata=solar(:,2);SData=cell(1,7);SData(1)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\二月\太阳能测光数据_2010-02.xls');solardata=[solardata; solar(:,2)]SData(2)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\三月\太阳能测光数据_2010-03-01 - 2010-04-01.xls');solardata=[solardata; solar(:,2)]SData(3)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\四月\太阳能测光数据_2010-04-01 - 2010-05-01.xls');solardata=[solardata; solar(:,2)]SData(4)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\五月\太阳能测光数据_2010-05-01 - 2010-06-01.xls');solardata=[solardata; solar(:,2)]SData(5)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\六月\太阳能测光数据_2010-06-01 - 2010-07-01.xls');solardata=[solardata; solar(:,2)]SData(6)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\七月\太阳能测光数据2010-7-1-2010-8-1.xls');solardata=[solardata; solar(:,3)]SData(7)=&#123;solar&#125;; 使用核密度估计对长时间内的光伏强度进行估计 代码实现 123456[fsd,sdc]=ecdf(solardata);[fks,ksc]=ksdensity(solardata,[-100:1:1200]);figure;ecdfhist(fsd,sdc,100);hold onplot(ksc,fks,'-r') 结果 频率分布 可以看到在长时间尺度上（上例为半年）核密度估计的拟合程度很高，但是在稍短的时间尺度上（一个月）则效果较差，如下图 该种情况可以通过调整窗的宽度来提高拟合优度，如下图为窗宽度为2.5时重新拟合一个月的光伏强度结果 当width=2.5时拟合结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[光伏建模——核密度估计而非Beta分布]]></title>
      <url>%2F2017%2F03%2F15%2F%E5%85%89%E4%BC%8F%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[光伏建模与风速建模的不同 对与风速建模而言，其符合双参数威布尔分布表示其样本数据符合双参数威布尔数据样本的特征 对于光伏建模而言，所谓的使用beta分布拟合光伏实际意义为在短时间内（一天之内）光照强度的曲线可以通过beta分布的概率密度函数去近似拟合 此二者有本质区别，因此如果仅通过曲线拟合表示光伏建模数据不能称作光伏建模随机性的数学表述，因此在缺乏先验的情况下只能求助于仅基于样本数据核密度估计 非参数核密度估计 定义 设\(x_1,x_2,...,x_n\)为随机变量\(x\)的样本，令随机变量\(x\)的概率密度函数为\(f(x)\)，则 \(f(x)\) 的核密度估计为： \[f_h(x)={1 \over nh}{\displaystyle \sum_{j=1}^n{K({x-x_j \over h})}}={1 \over n}{\displaystyle \sum_{j=1}^n{K_h(x-x_j)}}\] 其中\(n\)为样本容量，\(h\) 为平滑系数，\(K(·)\) 为核函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[混合Copula风速建模——代码实现与结果分析]]></title>
      <url>%2F2017%2F03%2F10%2F%E6%B7%B7%E5%90%88Copula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[由于仿真一次所耗时间较长，因此选择北大桥与干河口风电场作为代表 EM算法估计混合Copula参数 EM主体 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647U=GHK;V=BDQ;% 初始化S=3;th=0.01;omega=[1/3,1/3,1/3];[a,nuhat]=copulafit('t',[U,V]);a2=copulafit('Gumbel',[U,V]);a3=copulafit('Frank',[U,V]);theta=[a(1,2),a2,a3];[N,~]=size(U);count=0;tt=zeros(N,2);t=inf;COPULA=zeros(N,S);list1=zeros(3,101);list2=zeros(3,101);puz=zeros(N,S);puz1=zeros(N,S);while t&gt;=th&amp;&amp;count&lt;=100; theta_old=theta; omega_old=omega; COPULA(:,1)=copulapdf('t',[U(:) V(:)],theta_old(1),nuhat); COPULA(:,2)=copulapdf('Gumbel',[U(:) V(:)],theta_old(2)); COPULA(:,3)=copulapdf('Frank',[U(:) V(:)],theta_old(3)); puz(:,1)=COPULA(:,1)*omega_old(1); puz(:,2)=COPULA(:,2)*omega_old(2); puz(:,3)=COPULA(:,3)*omega_old(3); for i=1:N puz1(i,1)=puz(i,1)/sum(puz(i,:)); puz1(i,2)=puz(i,2)/sum(puz(i,:)); puz1(i,3)=puz(i,3)/sum(puz(i,:)); end omega(1)=sum(puz1(:,1))/N; omega(2)=sum(puz1(:,2))/N; omega(3)=sum(puz1(:,3))/N; omega tt(:,1)=tinv(U(:),nuhat); tt(:,2)=tinv(V(:),nuhat); [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,theta_old,puz1,tt,nuhat); theta=turntheta; theta list1(:,count+1)=theta; list2(:,count+1)=omega; t=max([norm(theta_old(:)-theta(:));norm(omega_old(:)-omega(:))]) count=count+1end 参数更新（非线性优化bfgs） 12345678910111213141516171819202122function [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,theta,puz,t,nuhat)options=optimset('Display','iter-detailed','TolFun',1e-10,'TolX',1e-10,'LargeScale','off','FinDiffType','central','HessUpdate','bfgs');[turntheta,fval,exitflag,output,grad,hessian]=fminunc(@utheta,theta,options);function y=utheta(theta)if theta(3)==0 theta(3)=theta(3)+0.0001; %防止出现 Frank Copula 的相依结构参数为 0endy=0;th=eye(2);th(1,2)=theta(1);th(2,1)=theta(1);for j=1:N y=y+log(((det(th))^(-1/2))*gamma((nuhat+2)/2)*gamma(nuhat/2)*(1+t(j,:)*th^(-1)*t(j,:)'/nuhat)^(-(nuhat+2)/2)/((gamma((nuhat+1)/2))^2*((1+t(j,1)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,2)^2/nuhat)^(-(nuhat+1)/2))))*puz(j,1)+... log(exp(-((-log(U(j)))^theta(2)+(-log(V(j)))^theta(2))^(1/theta(2)))*(log(U(j))*log(V(j)))^(theta(2)-1)*(((-log(U(j)))^(theta(2))+(-log(V(j)))^(theta(2)))^(1/theta(2))+theta(2)-1)/(U(j)*V(j)*((-log(U(j)))^(theta(2))+(-log(V(j)))^(theta(2)))^(2-1/theta(2))))*puz(j,2)+... log(theta(3)*(1-exp(-theta(3)))*exp(-theta(3)*(U(j)+V(j)))/((1-exp(-theta(3)))-(1-exp(-theta(3)*U(j)))*(1-exp(-theta(3)*V(j))))^2)*puz(j,3);endy=-y;endend 结果 Copula函数 \(\theta\) \(\omega\) \(k\) t-Copula 0.1244 0.0822 3 Gumbel-Copula 4.1127 0.7495 Frank-Copula 6.5931 0.1683 即 \[C(u,v;a)=0.7495C_{Gumbel}(u,v;4.1127)+0.1683C_{Frank}(u,v;6.5931)+0.0822C_t(u,v;0.1244,3)\] 结果评价 Q-Q图 可以与之前单一Copula的仿真QQ图进行比较 可以明显的看出拟合优度上混合Copula有很大的优势 K-S检验 风电场组合 \(k_N\) \(k_t\) \(k_G\) \(k_C\) \(k_F\) \(K_M\) 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 0.0271 可以看出就K-S统计值而言混合Copula也小于其他单一Copula 欧式距离 风电场组合 \(d_N\) \(d_t\) \(d_G\) \(d_C\) \(d_F\) \(d_M\) 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 1.3220 可以看出就欧式距离而言混合Copula也小于其他单一Copula PS：作为一个学电气的人一开始看到要使用一个从未见过的EM算法我几乎是拒绝的，要多谢CS的室友和我分享了有关这方面的知识并且和我一起探讨。这个程序跑起来确实让人奔溃，跑一次就要三个多小时，但是最后仿真出来的结果符合我推测确实让我很开心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[混合Copula函数风速建模——EM算法]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%B7%B7%E5%90%88Copula%E5%87%BD%E6%95%B0%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（5）——结果分析]]></title>
      <url>%2F2017%2F03%2F03%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%885%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Q-Q图分析 通过Q-Q图的判定原则可知，各类Copula函数差别不 很 明 显，其 中Gumbel-Copula，Frank-Copula，t-Copula函数曲线均较为接近45°曲线，拟合效果相对较好。以下采用统计法 K-S检验法 风电场组合 \(k_N\) \(k_t\) \(k_G\) \(k_C\) \(k_F\) 桥湾，北大桥 0.0406 0.0395 0.0302 0.0520 0.0364 桥湾，干河口 0.0260 0.0219 0.0156 0.0489 0.0208 桥湾，昌马 0.0260 0.0239 0.0156 0.0499 0.0239 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 北大桥，昌马 0.0239 0.0239 0.0156 0.0385 0.0166 干河口，昌马 0.0208 0.0208 0.0146 0.0385 0.0156 通过K-S检验法的判定原则可知，在六种不同的风电场组合中，Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数的 \(KS\) 统计值相对较小，而Normal-Copula，Clayton-Copula的统计值相对较大 秩相关性测度 数据来源 Kendall秩相关系数 \(\tau\) Spearman秩相关系数 \(\rho_s\) 原始观测数据 0.4816 0.6628 Normal-Copula 0.4371 0.6159 t-Copula 0.4410 0.6151 Gumbel-Copula 0.4604 0.6366 Clayton-Copula 0.2569 0.3751 Frank-Copula 0.4592 0.6465 通过与经验函数的Kendall秩相关系数，Spearman秩相关系数进行对比可以发现Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与原始数据保持着良好的秩相关性，而Normal-Copula，Clayton-Copula的秩相关性较差。 欧式距离 风电场组合 \(d_N\) \(d_t\) \(d_G\) \(d_C\) \(d_F\) 桥湾，北大桥 2.8924 2.8209 1.3953 9.1763 2.4125 桥湾，干河口 2.7285 2.6970 1.1862 8.2528 2.2180 桥湾，昌马 2.3450 2.2558 1.3469 8.3662 1.8227 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 北大桥，昌马 1.7187 1.7470 1.5995 5.0238 1.3692 干河口，昌马 1.8369 1.8561 1.3731 4.8842 1.4301 可以看到在以上6种风电场组合中Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与经验Copula函数的欧氏距离较小，而Normal-Copula，Clayton-Copula与经验函数的欧氏距离较大 结论 任何一个单一的Copula函数都不能够非常好的表达风电场的相依结构，因此考虑使用混合Copula函数，即将表现较好的3个Copula函数进行加权组合，即 \[C(u,v;a)=\omega_1C_{Gumbel}(u,v;\theta_1)+\omega_2C_{Frank}(u,v;\theta_2)+\omega_3C_t(u,v;\theta_3,k)\] 其中 \(\omega_1+ \omega_2+ \omega_3=1\)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关(4)——Copula模型评价]]></title>
      <url>%2F2017%2F03%2F02%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%884%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Q-Q图 代码实现 12345678910111213141516171819202122%计算网格点上Copula分布函数值画QQ图Ccdf_n=copulacdf('Gaussian',[Udata(:),Vdata(:)],rho_norm);Ccdf_t=copulacdf('t',[Udata(:),Vdata(:)],rho_t,nuhat);Ccdf_G=copulacdf('Gumbel',[Udata(:),Vdata(:)],paramhat_G);Ccdf_C=copulacdf('Clayton',[Udata(:),Vdata(:)],paramhat_C);Ccdf_F=copulacdf('Frank',[Udata(:),Vdata(:)],paramhat_F);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_n,size(Udata)),'b');xlabel('经验Copula');ylabel(['Normal Copula','rho:',num2str(rho_norm(1,2))]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Normal']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_t,size(Udata)),'b');xlabel('经验Copula');ylabel(['t-Copula','rho:',num2str(rho_t(1,2)),'k:',num2str(nuhat)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','t']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_G,size(Udata)),'b');xlabel('经验Copula');ylabel(['Gumbel-Copula','p_G:',num2str(paramhat_G)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Gumbel']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_C,size(Udata)),'b');xlabel('经验Copula');ylabel(['Clayton-Copula','p_C',num2str(paramhat_C)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Clayton']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_F,size(Udata)),'b');xlabel('经验Copula');ylabel(['Frank-Copula','p_F',num2str(paramhat_F)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Frank']); 结果 K-S检验 以北大桥与桥湾风电场为例 代码实现 123456%K-S检验[h_n,p_n,k_n]=kstest2(CopulaEmpirical',Ccdf_n)[h_t,p_t,k_t]=kstest2(CopulaEmpirical',Ccdf_t)[h_G,p_G,k_G]=kstest2(CopulaEmpirical',Ccdf_G)[h_C,p_C,k_C]=kstest2(CopulaEmpirical',Ccdf_C)[h_F,p_F,k_F]=kstest2(CopulaEmpirical',Ccdf_F) 结果 风电场组合 \(k_N\) \(k_t\) \(k_G\) \(k_C\) \(k_F\) 桥湾，北大桥 0.0406 0.0395 0.0302 0.0520 0.0364 桥湾，干河口 0.0260 0.0219 0.0156 0.0489 0.0208 桥湾，昌马 0.0260 0.0239 0.0156 0.0499 0.0239 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 北大桥，昌马 0.0239 0.0239 0.0156 0.0385 0.0166 干河口，昌马 0.0208 0.0208 0.0146 0.0385 0.0156 Copula函数的秩相关性测度 代码实现 123456789101112131415%Copula模型的相关性测度%使用原始数据计算秩相关系数Kendall=corr([X,Y],'type','Kendall')Spearman=corr([X,Y],'type','Spearman')%计算Copula的秩相关系数Kendall_norm = copulastat('Gaussian',rho_norm)Spearman_norm = copulastat('Gaussian',rho_norm,'type','Spearman')Kendall_t = copulastat('t',rho_t,nuhat)Spearman_t = copulastat('t',rho_t,nuhat,'type','Spearman')Kendall_G = copulastat('Gumbel',paramhat_G)Spearman_G = copulastat('Gumbel',paramhat_G,'type','Spearman')Kendall_C = copulastat('Clayton',paramhat_C)Spearman_C = copulastat('Clayton',paramhat_C,'type','Spearman')Kendall_F = copulastat('Frank',paramhat_F)Spearman_F= copulastat('Frank',paramhat_F,'type','Spearman') 结果 数据来源 Kendall秩相关系数 \(\tau\) Spearman秩相关系数 \(\rho_s\) 原始观测数据 0.4816 0.6628 Normal-Copula 0.4371 0.6159 t-Copula 0.4410 0.6151 Gumbel-Copula 0.4604 0.6366 Clayton-Copula 0.2569 0.3751 Frank-Copula 0.4592 0.6465 欧式距离计算 代码实现 1234567891011121314151617181920%----------------求欧式距离% 通过循环计算经验Copula函数在新产生的网格点处的函数值CUV=zeros(size(UU(:)));for i=1:numel(UU) CUV(i)=C(UU(i),VV(i));end%求各Copula函数在原始样本点处的函数值Cnorm=copulacdf('Gaussian',[UU(:),VV(:)],rho_norm);Ct=copulacdf('t',[UU(:),VV(:)],rho_t,nuhat);CG=copulacdf('Gumbel',[UU(:),VV(:)],paramhat_G);CC=copulacdf('Clayton',[UU(:),VV(:)],paramhat_C);CF=copulacdf('Frank',[UU(:),VV(:)],paramhat_F);%计算欧式距离dnorm=sqrt((CUV-Cnorm)'*(CUV-Cnorm))dt=sqrt((CUV-Ct)'*(CUV-Ct))dG=sqrt((CUV-CG)'*(CUV-CG))dC=sqrt((CUV-CC)'*(CUV-CC))dF=sqrt((CUV-CF)'*(CUV-CF)) 结果 风电场组合 \(d_N\) \(d_t\) \(d_G\) \(d_C\) \(d_F\) 桥湾，北大桥 2.8924 2.8209 1.3953 9.1763 2.4125 桥湾，干河口 2.7285 2.6970 1.1862 8.2528 2.2180 桥湾，昌马 2.3450 2.2558 1.3469 8.3662 1.8227 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 北大桥，昌马 1.7187 1.7470 1.5995 5.0238 1.3692 干河口，昌马 1.8369 1.8561 1.3731 4.8842 1.4301]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（3）——代码实现]]></title>
      <url>%2F2017%2F03%2F01%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%883%EF%BC%89%2F</url>
      <content type="text"><![CDATA[数据来源 使用甘肃桥湾（1），北大桥（2），干河口（3），昌马（4）四处风速数据作为仿真数据 数据处理 读入数据 123456%从文件中读取数据load('data.mat');qw=data(:,1);%桥湾bdq=data(:,4);%北大桥ghk=data(:,7);%干河口cm=data(:,10);%昌马 对风速进行双参数威布尔分布化 1234567891011121314151617181920%桥湾pqw=wblfit(qw);QW=wblpdf(1:50,pqw(1),pqw(2));QWC=wblcdf(qw,pqw(1),pqw(2));%北大桥pbdq=wblfit(bdq);BDQ=wblpdf(1:50,pbdq(1),pbdq(2));BDQC=wblcdf(bdq,pbdq(1),pbdq(2));%干河口pghk=wblfit(ghk);GHK=wblpdf(1:50,pghk(1),pghk(2));GHKC=wblcdf(ghk,pghk(1),pghk(2));%昌马pcm=wblfit(cm);CM=wblpdf(1:50,pcm(1),pcm(2));CMC=wblcdf(cm,pcm(1),pcm(2));d=&#123;qw,bdq,ghk,cm&#125;;D=&#123;QW,BDQ,GHK,CM&#125;;DD=&#123;QWC,BDQC,GHKC,CMC&#125;;N=&#123;'桥湾','北大桥','干河口','昌马'&#125;; 风电场 威布尔参数a 威布尔参数b 桥湾 8.1343 1.8773 北大桥 8.6619 1.7378 干河口 8.3685 1.5731 昌马 9.1261 2.1229 频率与频数直方图 频率分布直方图 12345678910111213141516171819202122232425262728293031323334353637383940%桥湾[fqw,qwc]=ecdf(qw);figure(1);ecdfhist(fqw,qwc,100);hold onplot(QW,'-r');title('桥湾');xlabel('风速');ylabel('f(x)');hold off%北大桥[fbdq,bdqc]=ecdf(bdq);figure(2);ecdfhist(fbdq,bdqc,100);hold onplot(BDQ,'-r');title('北大桥');xlabel('风速');ylabel('f(x)');hold off%干河口[fghk,ghkc]=ecdf(ghk);figure(3);ecdfhist(fghk,ghkc,100);hold on;plot(GHK,'-r');title('干河口');xlabel('风速');ylabel('f(x)');hold off%昌马[fcm,cmc]=ecdf(cm);figure(4);ecdfhist(fcm,cmc,100);hold onplot(CM,'-r');title('昌马');xlabel('风速');ylabel('f(x)');hold off 结果 频率分布直方图 频数分布直方图 123456789for i=1:4 for j=i+1:4 figure; hist3([DD&#123;i&#125;(:) DD&#123;j&#125;(:)],[50,50]); xlabel(N&#123;i&#125;); ylabel(N&#123;j&#125;); zlabel('频数'); endend 结果 风电场间频数直方图 各Copula函数 Copula函数参数估计 12345rho_norm = copulafit('Gaussian',[U,V]);[rho_t,nuhat,nuci]=copulafit('t',[U,V]);paramhat_G=copulafit('Gumbel',[U,V]);paramhat_C=copulafit('Clayton',[U,V]);paramhat_F=copulafit('Frank',[U,V]); 结果 风电场组合 \(\rho_{Norm}\) \(\rho_t\) \(k\) \(\theta_G\) \(\theta_C\) \(\theta_F\) 桥湾与北大桥 0.6339 0.6386 9.1619 1.8533 0.6913 5.0402 桥湾与干河口 0.5346 0.5364 9.7829 1.6350 0.4847 3.8853 桥湾与昌马 0.6108 0.6169 10.4474 1.7697 0.6530 4.8459 北大桥与干河口 0.8092 0.8479 2.7192 2.9270 1.4685 9.8959 北大桥与昌马 0.3639 0.3630 33.9054 1.3098 0.3072 2.3697 干河口与昌马 0.3028 0.3026 21.9903 1.2628 0.2141 1.9736 经验Copula 1234567891011121314%计算经验分布[fx,xsort]=ecdf(X);[fy,ysort]=ecdf(Y);%调用spine函数利用样条插值计算原始样本点的经验分布函数值UU=spline(xsort(2:end),fx(2:end),X);VV=spline(ysort(2:end),fy(2:end),Y);%定义经验Copula函数C=@(u,v)mean((UU&lt;=u).*(VV&lt;=v));[Udata,Vdata] = meshgrid(linspace(0,1,31));%循环计算经验Copula函数值for i=1:numel(Udata) CopulaEmpirical(i)=C(Udata(i),Vdata(i));end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（2）——函数性质以及常用代码]]></title>
      <url>%2F2017%2F02%2F28%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1 二元Copula函数的定义以及性质 定义: 二元Copula函数是指满足以下性质的函数\(C(u,v)\): \(C(u,v)\) 的定义域为[0,1]x[0,1]； \(C(u,v)\) 有零基面，并且是二维递增的； 对任意\(u,v\in [0,1]\)，满足\(C(u,1)=u，C(1,v)=v\)。 所谓的有零基面是：至少存在一个\(u_0\in[0,1]\) 和一个\(v_0\in[0,1]\)，使得\(C(u_0,v)=0=C(u,v_0)\)。 二维递增是指：对任意\(0\le u_1\le u_2\le1\)和\(0\le v_1\le v_2\le1\)，有 \[C(u_2,v_2)-C(u_2,v_1)-C(u_1,v_2)+C(u_1,v_1)\ge 0\] 性质： 二元Copula函数满足以下性质： \(C(u,v)\) 关于每一个变量都是单调非减的 对于任意的\(u,v\in[0,1],C(u,0)=C(0,v)=0,C(u,1)=u,C(1,v)=v\) 对任意\(0\le u_1\le u_2\le1\)和\(0\le v_1\le v_2\le1\)，有 \[C(u_2,v_2)-C(u_2,v_1)-C(u_1,v_2)+C(u_1,v_1)\ge 0\] 对任意的\(u_1,u_2,v_1,v_2\in[0,1]\)，有 \(|C(u_2,v_2)-C(u_1,v_1)|\le|u_2-u_1|+|v_2-v_1|\)。 对任意\(u,v\in[0,1],max(u+v-1,0)\le C(u,v) \le min(u,v)\)，令 \(C^-(u,v)=max(u+v-1,0),C^+(u,v)=min(u,v)\)，则称\(C^-(u,v)和 C^+(u,v)\) 分别为Frechet上界和下界 若\(U,V\) 独立且同服从 \([0,1]\) 上的均匀分布，则\(C(u,v)=uv\)。 多元Copula函数的定义及性质 定义： N元Copula函数是指满足以下性质的函数 \(C(u_1,u_2,...,u_N)\) ： 定义域为 \([0,1]^N\) \(C(u_1,u_2,...,u_N)\) 有零基面，并且是N维递增的； \(C(u_1,u_2,...,u_N)\) 有边缘分布函数 \[ C_i(u_i)=C(1,...,1,u_i,1,...,1)=u_i \] 其中 \(u_i \in [0,1](i=1,2,...,N)\) 。 性质： 多元Copula函数具备以下性质： \(C(u_1,u_2,...,u_N)\) 关于每个变量都是单调非减得 \(C(u_1,u_2,...,0,...,u_N)=0,C(1,...,1,u_i,1,...,1)=u_i\) 。 对任意的 \(u_i,v_i \in [0,1](i=1,2,...,N)\) ，有 \[|C(u_1,u_2,...,u_N)|-C(v_1,v_2,...,v_N) \le {\displaystyle \sum _{i=1}^N {|u_i-v_i|}}\] 令 \(C^-(u_1,u_2,...u_N)=max({\displaystyle\sum_{i=1}^N{u_i-N+1,0}})\) ， \(C^+(u_1,u_2,...,u_N)=min(u_1,u_2,...,u_N)\) ，则对任意的 \(u_i\in [0,1](i=1,2,...,N)\) ，有 \[C^-(u_1,u_2,...u_N)\le C(u_1,u_2,...,u_N)\le C^+(u_1,u_2,...,u_N)\] 记为 \(C^-\prec C\prec C^+\) 。称 \(C^-\) 和 \(C^+\) 分别为Frechet上下界，当 \(N\ge 2\) 时，\(C^+\) 是一个N元Copula函数，但是当 \(N&gt;2\) 时， \(C^-\) 并不是一个Copula函数 若 \(U_i\sim U(0,1)(i=1,2,...,N)\) 相互独立，则 \(C(u_1,u_2,...,u_N)={\displaystyle \prod _{i=1}^N{u_i}}\) MATLAB常用Copula函数 copulafit 123456789%估计正态Copula中的参数1. RHOHAT=copulafit('Gaussian',U)%估计t-Copula中的参数2. [RHOHAT,nuhat]=copulafit('t',U)3. [RHOHAT,nuhat,nuci]=copulafit('t',U)%估计二元阿基米德Copula中的参数（包括Clayton，Frank，Gumbel）4. paramhat=copulafit(family,U)5. [paramhat,paramci]=copulafit(family,U)... copulastat 12345678%计算正态Copula对应的Kendall秩相关系数1. R=copulastat('Gaussian',rho)%计算t-Copula对应的Kendall秩相关系数2. R=copulastat('t',rho,NU)%计算二元阿基米德Copula对应的Kendall秩相关系数（family字段可选Clayton，Frank，Gumbel）3. R=copulastat(family,alpha)%计算由type参数制定的秩相关系数R可选字段为'Kendall','Spearman'4. R=copulastat(...,'type',type) copulaparam 根据秩相关系数求解Copula中的 \(\rho\) 或 \(\alpha\) 12345678%计算正态Copula中的线性相关参数ρ1. rho=copulaparam('Gaussian',R)%计算t-Copula中的线性相关参数ρ2. rho=copulaparam('t',R,NU)%计算二元阿基米德Copula中的参数α3. alpha=copulaparam(family,R)%用type参数指定秩相关系数的类型4. [...]=copulaparam(...,'type',type) copulapdf 用于计算Copula的密度函数值 1231. y = copulapdf('Gaussian',u,rho)2. y = copulapdf('t',u,rho,nu)3. y = copulapdf(family,u,alpha) copulacdf 用于计算Copula分布函数值 1231. y = copulacdf('Gaussian',u,rho)2. y = copulacdf('t',u,rho,nu)3. y = copulacdf(family,u,alpha) PS:双参数威布尔分布常用函数：wblfit,wblpdf,wblcdf Copula经验分布函数的求取 123456789101112131415161718192021222324252627% 调用ecdf函数求X和Y的经验分布函数[fx, Xsort] = ecdf(X);[fy, Ysort] = ecdf(Y);% 调用spline函数，利用样条插值法求原始样本点处的经验分布函数值U = spline(Xsort(2:end),fx(2:end),X);V = spline(Ysort(2:end),fy(2:end),Y);% 定义经验Copula函数C(u,v)C = @(u,v)mean((U &lt;= u).*(V &lt;= v));% 为作图的需要，产生新的网格数据[Udata,Vdata] = meshgrid(linspace(0,1,31));% 通过循环计算经验Copula函数在新产生的网格点处的函数值for i=1:numel(Udata) CopulaEmpirical(i) = C(Udata(i),Vdata(i));endfigure; % 新建图形窗口% 绘制经验Copula分布函数图像surf(Udata,Vdata,reshape(CopulaEmpirical,size(Udata)))xlabel('U'); % 为X轴加标签ylabel('V'); % 为Y轴加标签zlabel('Empirical Copula C(u,v)'); % 为z轴加标签% 通过循环计算经验Copula函数在原始样本点处的函数值CUV = zeros(size(U(:)));for i=1:numel(U) CUV(i) = C(U(i),V(i));end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（1）——相关参数]]></title>
      <url>%2F2017%2F02%2F27%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Copula函数的拟合优度校验——与经验Copula函数对比 QQ图（Q-QNorm） 把数据的分位数与已知分布相比较，从而来判断数据的分布情况。把已知分布的分位数标在纵轴上，样本分位数标在横轴上，从图形上可以了解到分布的信息。图形是直线说明是正态分布。图形中有一段是直线，在两端存在弧度，说明峰度的情况。 图形是曲线图，说明不对称。 如果Q-Q图是直线，当该直线成45度角并穿过原点时，说明分布与给定的正态分布完全一样。 如果是成45度角但不穿过原点，说明均值与给定的正态分布不同 如果是直线但不是45度角，说明均值与方差都与给定的分布不同。 如果Q-Q图中间部分是直线，但是右边在直线下面，左边在直线上面，说明分布的峰度大于3，反之说明峰度小于3. K-S检验法（Kolmogorov-Smirnov test） 检验数据是否符合某种分布 Kolmogorov-Smirnov是比较一个频率分布f(x)与理论分布g(x)或者两个观测值分布的检验方法。其原假设H0:两个数据分布一致或者数据符合理论分布。 \(D=max| f(x)- g(x)|\) ，当实际观测值D&gt;D(n,α)则拒绝H0，否则则接受H0假设。 KS检验与t-检验之类的其他方法不同是KS检验不需要知道数据的分布情况，可以算是一种非参数检验方法。当然这样方便的代价就是当检验的数据分布符合特定的分布事，KS检验的灵敏度没有相应的检验来的高。在样本量比较小的时候，KS检验最为非参数检验在分析两组数据之间是否不同时相当常用。 PS：t-检验的假设是检验的数据满足正态分布，否则对于小样本不满足正态分布的数据用t-检验就会造成较大的偏差，虽然对于大样本不满足正态分布的数据而言t-检验还是相当精确有效的手段。 本例中使用kstest2函数 对风电场风速进行处理——双参数威布尔分布 双参数威布尔函数 \[F_w(x)=1-exp(-({x \over c})^k)\] 其概率密度函数为 \[P(x)={k \over c} ({k \over c})^{k-1}exp(-({x \over c})^k)\] 式中 \(k\) 为形状参数，无量纲； \(c\) 为尺度参数，反映风电场的平均风速，单位为 \(m/s\) 。 Pearson相关系数 简介 皮尔逊相关也称为积差相关（或积矩相关）是英国统计学家皮尔逊于20世纪提出的一种计算直线相关的方法。在本例中主要用于对两组风速曲线的相关性进行表示 假设有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算： 公式一： \[ \rho_{X,Y}={cov(X,Y) \over \sigma_X \sigma_Y}={E((X-\mu_X)(Y-\mu_Y))\over \sigma_X \sigma_Y}={E(XY)-E(X)E(Y)\over \sqrt{E(X^2)-E^2(X)}\sqrt{E(Y^2)-E^2(Y)}}\] 公式二： \[\rho_{X,Y}={N\sum{XY}-\sum{X} \sum{Y} \over\sqrt{N\sum{X^2}-(\sum{X})^2}\sqrt{N\sum{Y^2}-(\sum{Y})^2}}\] 公式三： \[\rho_{X,Y}={\sum(X-\overline{X})(Y-\overline{Y}) \over\sqrt{\sum(X-\overline{X})^2\sum(Y-\overline{Y})^2}}\] 公式四： \[\rho_{X,Y}={\sum{XY}-{\sum{X}\sum{Y}\over N}\over\sqrt{(\sum{X^2}-{(\sum{X})^2\over N})}\sqrt{(\sum{Y^2}-{(\sum{Y})^2\over N})}}\] 以上列出的四个公式等价，其中E是数学期望，cov表示协方差，N表示变量取值的个数。 适用范围 当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于： 两个变量之间是线性关系，都是连续数据。 两个变量的总体是正态分布，或接近正态的单峰分布。 两个变量的观测值是成对的，每对观测值之间相互独立。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Copula理论的风电场间建模]]></title>
      <url>%2F2017%2F02%2F21%2F%E5%9F%BA%E4%BA%8ECopula%E7%90%86%E8%AE%BA%E7%9A%84%E9%A3%8E%E7%94%B5%E5%9C%BA%E9%97%B4%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[关于研究目的 由于风电基地的多个风电场地理位置比较靠近，且基本处于同一风带，风速之间具有较强的相关性，使得多个风电场的总体特性不同于单个风电场的特性。 通过Copula理论进行多个风电场风俗的联合概率分布研究。 Copula理论 关于Copula函数 Copula函数在网络中所能检索到的信息 Copula函数百度 Copula函数描述的是变量间的相关性，实际上是一类将联合分布函数与它们各自的边缘分布函数连接在一起的函数，因此也有人将它称为连接函数。相关理论的提出可以追溯到1959年，SKlar通过定理形式将多元分布与Copula函数联系起来。 20世纪90年代后期相关理论和方法在国外开始得到迅速发展并应用到金融，保险等领域的相关分析，投资组合分析和风险管理等多个方面。 定义:(Nelsen.2006) N 元Copula函数是指具有以下性质的函数（下记为C）： （1）定义域为[0,1]×[0,1]×。。。×[0,1] （共为N个域相乘）； （2）C具有零基面（grounded）且是N维递增的； （3）C的边缘分布Cn，n=1,2,,,,N,满足Cn(xn)=C(1,…,1,xn,1,,,1)=xn，其中xn∈[0,1],n=1,2,,,N CopulaWIKI 要点： - 边缘分布与联合分布的概念 - 关于风速的概率分布问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 第二次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass2%2F</url>
      <content type="text"><![CDATA[封装继承多态 1. 父类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */class Robot &#123; protected String r_id; protected int speed; //private double temp; public Robot()&#123; r_id = JOptionPane.showInputDialog(null, "r_id = ", "请输入ID", JOptionPane.QUESTION_MESSAGE ); speed = Integer.parseInt( JOptionPane.showInputDialog(null, "speed = ", "请输入速度", JOptionPane.QUESTION_MESSAGE )); /*temp = Double.parseDouble(JOptionPane.showInputDialog(null, "temp = ", "请输入温度", JOptionPane.QUESTION_MESSAGE ));*/ &#125; public String judge()&#123; if (speed&gt;120)&#123; speed = 115; return "您超速了"; &#125;else&#123; //speed = 40; return "您的速度正常"; &#125; &#125; public void output()&#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = "+r_id+"\n"+"speed = "+speed +"\n" /*+ "temp = "+temp+"\n"*/+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; 2. 子类 2.1 子类1（WarRobot） 1234567891011121314151617181920212223242526272829303132333435363738394041package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class WarRobot extends Robot &#123; private int weapon_count; //private String r_id; //private int speed; //private double temp; public WarRobot() &#123; super(); weapon_count = Integer.parseInt(JOptionPane.showInputDialog(null, "weapon_count = ", "请输入武器数量", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge() &#123; if (weapon_count &gt; 10) &#123; speed = 200; return "您是战神"; &#125; else &#123; //speed = 40; return "您是菜鸟"; &#125; &#125; public void output() &#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = " + r_id + "\n" + "speed = " + speed + "\n" + "weapon_count = " + weapon_count + "\n" + judge() + "\n", "战斗机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; 2.2 子类2（HomeRobot） 123456789101112131415161718192021222324252627282930313233343536373839404142package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class HomeRobot extends Robot&#123; private int skill_count; //protected String r_id; //protected int speed; //private double temp; public HomeRobot()&#123; super(); skill_count = Integer.parseInt(JOptionPane.showInputDialog(null, "skill_count = ", "请输入技能数", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge()&#123; if (skill_count&gt;5)&#123; // speed = 115; return "你是家务大师"; &#125;else&#123; //speed = 40; return "您是家务菜鸟"; &#125; &#125; public void output()&#123; super.output(); JOptionPane.showMessageDialog(null,//父容器 "skill_count = "+skill_count+"\n"+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; 2.3 UML类图 抽象类 1. 父类抽象类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */abstract class Robot &#123; protected String r_id; protected int speed; //private double temp; public Robot()&#123; r_id = JOptionPane.showInputDialog(null, "r_id = ", "请输入ID", JOptionPane.QUESTION_MESSAGE ); speed = Integer.parseInt( JOptionPane.showInputDialog(null, "speed = ", "请输入速度", JOptionPane.QUESTION_MESSAGE )); /*temp = Double.parseDouble(JOptionPane.showInputDialog(null, "temp = ", "请输入温度", JOptionPane.QUESTION_MESSAGE ));*/ &#125; public String judge()&#123; if (speed&gt;120)&#123; speed = 115; return "您超速了"; &#125;else&#123; //speed = 40; return "您的速度正常"; &#125; &#125; public void output()&#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = "+r_id+"\n"+"speed = "+speed +"\n" /*+ "temp = "+temp+"\n"*/+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); public void abstract run(); &#125;&#125; 2.子类 2.1 子类1 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class WarRobot extends Robot &#123; private int weapon_count; //private String r_id; //private int speed; //private double temp; public WarRobot() &#123; super(); weapon_count = Integer.parseInt(JOptionPane.showInputDialog(null, "weapon_count = ", "请输入武器数量", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge() &#123; if (weapon_count &gt; 10) &#123; speed = 200; return "您是战神"; &#125; else &#123; //speed = 40; return "您是菜鸟"; &#125; &#125; public void output() &#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = " + r_id + "\n" + "speed = " + speed + "\n" + "weapon_count = " + weapon_count + "\n" + judge() + "\n", "战斗机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125; public void run()&#123; System.out.println("我像风一样的奔跑"); &#125;&#125; 2.2 子类2（HomeRobot） 123456789101112131415161718192021222324252627282930313233343536373839404142434445package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class HomeRobot extends Robot&#123; private int skill_count; //protected String r_id; //protected int speed; //private double temp; public HomeRobot()&#123; super(); skill_count = Integer.parseInt(JOptionPane.showInputDialog(null, "skill_count = ", "请输入技能数", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge()&#123; if (skill_count&gt;5)&#123; // speed = 115; return "你是家务大师"; &#125;else&#123; //speed = 40; return "您是家务菜鸟"; &#125; &#125; public void output()&#123; super.output(); JOptionPane.showMessageDialog(null,//父容器 "skill_count = "+skill_count+"\n"+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125; public void run()&#123; System.out.println("我像仙女一样在飘"); &#125;&#125; 3. 运行程序 123456789101112131415161718192021222324252627282930package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */public class MainProg&#123; public static void main (String [] args)&#123;// 命令行运行输入的参数 Robot r1;//为超类Robot新建一个引用 WarRobot wr = new WarRobot(); wr.output(); HomeRobot hr = new HomeRobot(); hr.output(); //将超类Robot的引用r1指向子类WarRobot的对象wr r1 = wr; r1.run(); r1 = hr; r1.run(); //Robot r1 = new WarRobot(); &#125;&#125; 接口 1. 接口 123456package Program;public interface Robot &#123; public final int SPEED=100; public abstract void walk();&#125; 123456package Program;public interface MusicRobot &#123; public final int PLAY_KINDS=10; public abstract void play();&#125; 123456package Program;public interface WarRobot extends Robot&#123; public final int WEAPON_COUNT=15; public abstract void war();&#125; 123456package Program;public interface HomeRobot extends Robot&#123; public final int SKILL_COUNT=8; public abstract void cook();&#125; 2. 子类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package Program;public class SuperRobot implements HomeRobot,WarRobot,MusicRobot&#123; private String id; private int SuperAbility; public SuperRobot(String i,int s)&#123; id=i; SuperAbility=s; &#125; public void judge()&#123; if (SuperAbility&gt;120)&#123; System.out.println("您太厉害了"); &#125; else&#123; System.out.println("您还需要继续修炼"); &#125; &#125; public void cook() &#123; // TODO Auto-generated method stub System.out.println("I can cook!"); &#125; public void walk() &#123; // TODO Auto-generated method stub System.out.println("I can walk!"); &#125; public void war() &#123; // TODO Auto-generated method stub System.out.println("I can war!"); &#125; public void play() &#123; // TODO Auto-generated method stub System.out.println("I can play instruments!"); &#125; public void output()&#123; System.out.println("id="+id+"\nSuperAbility="+SuperAbility); &#125;&#125; 3. 执行程序 12345678910111213141516171819package Program;public class MainProgram &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub SuperRobot r=new SuperRobot("r001",10); r.judge(); r.walk(); r.war(); r.cook(); r.play(); r.output(); &#125;&#125; 4. UML图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java第四次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass4%2F</url>
      <content type="text"><![CDATA[1. 基础面板搭建 12345678910111213141516171819202122232425262728293031package mygame;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * Created by fatel on 2016/5/28. */public class CartoonApp extends JFrame implements ActionListener&#123; public CartoonApp()&#123; &#125; @Override public void actionPerformed(ActionEvent e) &#123; &#125; class CartoonPaint extends JPanel&#123; &#125; public static void main (String [] args)&#123; CartoonApp ca = new CartoonApp(); ca.setTitle("我的第一个动画程序"); ca.setBounds(300,200,400,450); ca.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ca.setVisible(true); &#125;&#125; 2. 变量定义 123456789101112JPanel [] pnl = &#123;new JPanel(new BorderLayout()), new JPanel(new FlowLayout()), new JPanel(new BorderLayout()), new JPanel(new FlowLayout())&#125;; String [] str = &#123;"North", "Center", "South"&#125;; JLabel lblTitle = new JLabel("我的第一个动画程序"); JButton [] btn = &#123;new JButton("start"), new JButton("pause"), new JButton("resume"), new JButton("exit")&#125;; int x,y,z; Random rnd = new Random(); Color [] c = &#123;Color.red, Color.green, Color.blue,Color.pink, Color.yellow&#125;; CartoonPaint cp = new CartoonPaint(); 3.基本图形绘制 123456789101112class CartoonPaint extends JPanel&#123; public void paintComponent(Graphics g)&#123; g.setColor(c[0]); g.drawOval(10,10,100,100); g.fillOval(120,10,100,100); g.drawRect(230,10,100,100); g.fillRect(340,10,100,100); int [] x1 = &#123;100, 50,150&#125;; int [] y1 = &#123;50,150, 150&#125;; g.drawPolygon(new Polygon(x1,y1,x1.length)); &#125; &#125; 4. 异常 123456789101112131415public void actionPerformed(ActionEvent ae) &#123; try&#123; if (ae.getSource()==btn[0])&#123; &#125;else if (ae.getSource()==btn[1])&#123; &#125;else if (ae.getSource()==btn[2])&#123; &#125;else if (ae.getSource()==btn[3])&#123; System.exit(0); &#125; &#125;catch(Exception ex)&#123; JOptionPane.showMessageDialog(null,ex.getMessage()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java第三次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass3%2F</url>
      <content type="text"><![CDATA[GUI设计 1. 框架 123456789101112131415161718192021222324package AreaCalculate;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * Created by fatel on 2016/5/14. */public class CircleArea extends JFrame implements ActionListener&#123; public CircleArea()&#123; &#125; public void actionPerformed(ActionEvent ae)&#123; &#125; public static void main(String [] args)&#123; &#125;&#125; 2. 主界面 12345CircleArea ca = new CircleArea();ca.setTitle("圆面积的计算");ca.setBounds(400,300,280,180);ca.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);ca.setVisible(true); 3. 搭建面板 1234567891011121314JPanel p0 = new JPanel();JPanel p1 = new JPanel();JPanel p2 = new JPanel();JPanel p3 = new JPanel();JLabel l0 = new JLabel("圆面积计算系统", JLabel.CENTER);JLabel l1 = new JLabel("请输入圆的半径：", JLabel.CENTER);JLabel l2 = new JLabel("圆的面积是：", JLabel.CENTER);JTextField t1 = new JTextField(10);JTextField t2 = new JTextField(10);JButton b1 = new JButton("计算");JButton b2 = new JButton("清空"); 4. 面板布局 123456789101112131415161718192021222324p1.setLayout(fl);p1.setBackground(Color.yellow);p1.add(l0);p2.setLayout(new GridLayout(2,2,5,5));p2.setBackground(Color.green);p2.add(l1);p2.add(t1);p2.add(l2);t2.setEditable(false);//t2不可编辑p2.add(t2);p3.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));p3.setBackground(Color.pink);b1.addActionListener(this);b2.addActionListener(this);//添加监听器p3.add(b1);p3.add(b2);p0.add("North", p1);p0.add("Center", p2);p0.add("South", p3);this.setContentPane(p0); 5. 事件处理 12345678public void actionPerformed(ActionEvent ae)&#123; if (ae.getSource()==b1)&#123; t2.setText(""+3.1415926*Double.parseDouble(t1.getText())*Double.parseDouble(t1.getText())); &#125;else&#123; t1.setText(""); t2.setText(""); &#125;&#125; 6. 代码优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950JPanel []p = new JPanel[4];Color [] c = &#123;Color.red, Color.yellow, Color.green, Color.pink&#125;;LayoutManager [] lm = &#123; new BorderLayout(5,5), new FlowLayout(FlowLayout.CENTER, 5, 5), new GridLayout(2,2,5,5), new FlowLayout(FlowLayout.CENTER, 5, 5)&#125;;String [] str = &#123;"圆面积计算系统", "请输入圆的半径：", "圆的面积是："&#125;;JLabel [] l = new JLabel[3];JTextField [] t = new JTextField [2];String [] str1 = &#123;"计算", "清空"&#125;;JButton [] b = new JButton[2];public CircleArea()&#123; for (int i = 0;i &lt; p.length;i++)&#123; p[i] = new JPanel(lm[i]); p[i].setBackground(c[i]); &#125; for (int i = 0;i &lt; l.length;i++)&#123; l[i] = new JLabel(str[i], JLabel.CENTER); &#125; for (int i = 0;i &lt; t.length;i++)&#123; t[i] = new JTextField(10); &#125; for (int i = 0;i &lt; b.length;i++)&#123; b[i] = new JButton(str1[i]); b[i].addActionListener(this); p[3].add(b[i]); &#125; p[1].add(l[0]); p[2].add(l[1]); p[2].add(t[0]); p[2].add(l[2]); t[1].setEditable(false); p[2].add(t[1]); p[0].add("North", p[1]); p[0].add("Center", p[2]); p[0].add("South", p[3]); this.setContentPane(p[0]);&#125; 7. 异常处理 7.1 throw 123456789public void actionPerformed(ActionEvent ae) throws NumberFormatException&#123; if (ae.getSource()==b[0])&#123; area=String.format("%5f", 3.1415926*Double.parseDouble(t[0].getText())*Double.parseDouble(t[0].getText())); t[1].setText(area); &#125;else&#123; t[0].setText(""); t[1].setText(""); &#125;&#125; 7.2 try catch 123456789101112131415 public void actionPerformed(ActionEvent ae) throws NumberFormatException&#123; try&#123; if (ae.getSource()==b[0])&#123; area=String.format("%5f", 3.1415926*Double.parseDouble(t[0].getText())*Double.parseDouble(t[0].getText())); t[1].setText(area); &#125;else&#123; t[0].setText(""); t[1].setText(""); &#125; &#125; catch (NumberFormatException nfe)&#123; JOptionPane.showMessageDialog(null, nfe.getMessage(),"异常消息",JOptionPane.ERROR_MESSAGE); &#125;&#125; 7.3 异常类 12345678910111213141516171819202122232425262728293031323334public void actionPerformed(ActionEvent ae) throws NumberFormatException &#123; try &#123; if (ae.getSource() == b[0]) &#123; if (t[0].getText().equals(""))&#123; throw new MyException("半径不能为空，请重新输入！！！"); &#125;else &#123; area = String.format("%5f", 3.1415926 * Double.parseDouble(t[0].getText()) * Double.parseDouble(t[0].getText())); t[1].setText(area); &#125; &#125; else &#123; t[0].setText(""); t[1].setText(""); &#125; &#125; catch (MyException me) &#123; JOptionPane.showMessageDialog(null, me.outExceMessage(), "异常消息", JOptionPane.ERROR_MESSAGE); &#125;catch (NumberFormatException nfe)&#123; JOptionPane.showMessageDialog(null, "输入不能为非数字，请重新输入", "异常消息", JOptionPane.ERROR_MESSAGE); t[0].setText(""); t[1].setText(""); &#125;&#125;class MyException extends NumberFormatException &#123; private String str; public MyException(String s) &#123; str = s; &#125; public String outExceMessage() &#123; return str; &#125;&#125;//类中类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于星球全景图的拍摄]]></title>
      <url>%2F2016%2F07%2F17%2F%E5%85%B3%E4%BA%8E%E6%98%9F%E7%90%83%E5%85%A8%E6%99%AF%E5%9B%BE%E7%9A%84%E6%8B%8D%E6%91%84%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可延迟负荷控制]]></title>
      <url>%2F2016%2F07%2F06%2F%E5%8F%AF%E5%BB%B6%E8%BF%9F%E8%B4%9F%E8%8D%B7%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Notes of Real-time deferrable load control: handling the uncertainties of renewable generation 简介 趋势：传统的煤炭、核能等发电能源逐渐被可再生能源所取代 可再生能源的不规律、不可预测性给控制带来了很多麻烦 需求响应：引导用户的动态电力负载需求管理与电力供应情况相匹配，可以弥补可再生能源的不确定性造成的影响 deferrable load：可以推迟一段时间再执行，可以通过推迟负荷时间来与可再生能源的供给匹配 要点：分散式直接负荷控制 ## 总结 提供了一个考虑未来时间段的负载与可再生能源状态预测的实时分布式可延迟负载控制算法 建模 给可延迟负载排了时间表 一个有限时间域里的离散时间模型（一天，十分钟为间隔） 可再生能源与非可延迟负载 非可延时负载在低聚程度上很难有效预测 将可再生能源发电机与非可延时类负载聚合到一个进程——基础负载 是非可延迟负载与可再生能源之间的误差 滤波器？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于柔性建模]]></title>
      <url>%2F2016%2F07%2F05%2Fflexibility%2F</url>
      <content type="text"><![CDATA[智能电网柔性成分运行建模方法研究 研究可调负荷和储能的运行特性，并建立其运行模型；研究柔性成分与可再生能源联合运行方式；仿真模拟可调负荷和储能运行的减排效果，验证所建模型有效性。 - 存在大量的DER（分布式能源），其潜在的供需调节能力尚未被完全开发和利用： - 电――化学类：钠硫电站、电动汽车、充换电站、气电转换。 - 电――热转换类: 空调、地暖、电热水器、蓄热、蓄冷、蓄冰等，调节特性受热力/耗散方程的约束。 - 纯电类需求响应：通过工作时间的调整响应电力波动，实现供需两侧之间的缓冲调节功能（类储能功能）。e.g:洗衣机、洗碗机、etc. - 基本描述：参与方申报可承受功率曲线范围、服务的最早开始时间和能量水平、最晚结束（完成）时间和能量水平、可承受价格范围、最大可中断次数等。云服务器端进行在线优化、实时结算和价格发布。 - 实现虚拟储能网的关键技术――1、设备间的统一通讯标准和规约、即插即识别即用、智能家居；2、电力传输网络的建模，阻塞与网损管理；3、有效的电价信号、激励机制和商业模式；4、对设备和其拥有者信息的有效保护。 - 研究内容：1、DER的统一建模；2、电力传输网络的建模；3、信息安全；4、电价设计；5、实施效果的检验与仿真；6、现场测试。 - 项目成效及应用前景：1、调峰效果；2、延缓输配电系统投资的效果（线路、变压器、线路）；3、运行效益（网损、运维、检修灵活性）；4、促进随机间歇性可再生能源消纳与碳减排效果；5、社会效益。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[notes]]></title>
      <url>%2F2016%2F07%2F05%2Fnotes%2F</url>
      <content type="text"><![CDATA[Notes about Large-scale integration of deferrable demand and renewable energy sources ABSTRACT stochastic unit commitment model 随机机组组合模型 ？ [ ]deferrable demand in power system 电力系统中的可暂缓需求（可调性需求？） [x]reserve requirements 储能需求 [ ]the benefits of demand flexibility 需求弹性收益 ？ [x]three demand response paradigms 三个需求响应的样例 &gt; - [ ]the centralized co-optimization of generation 发电的集中联合优化 ？ &gt; - [x]demand by the system operator, demand bids 来自于系统操作人员和订单的需求 &gt; - [ ]the coupling of renewable resources with deferrable loads 可再生能源与可调性负载的耦合 ？ [ ]motivate coupling as an alternative for overcoming the drawbacks of the two alternative demand response options 将耦合作为克服另外两个需求响应缺点的替代选项 [x]a dynamic programming algorithm for coordinating deferrable demand with renewable supply 一个用于协调可调性需求与可再生能源供给的动态算法 [ ]simulation results for a model of the Western Electricity Coordinating Council 关于西部电力协调理事会的模型仿真结果 [ ]load management 负载管理 [ ]power generation scheduling 电力发电规划 [ ]wind power generation 风力发电 INTRODUCTION high variability, unpredictable fluctuation, a limited control of output 与传统发电方式相比，可再生能源的关键缺陷在于它的高变化性，波动不可预测和输出仅在有限范围内可控 demand response 需求响应对于大规模的可再生能源是很有好处的 represent the balancing operations of the remaining grid by using a unit commitment model 用一个机组组合模型来表示当前电网的平衡措施来评估可再生能源与需求响应的影响 doesn’t model the deferrable nature of various of various demand response or account for the uncertainty that is introduced by the large-scale integration of renewable resources 以往这个领域的研究没有就变化的需求响应的可调性特征建模，也没有考虑由大规模可再生能源导致的不确定性 economic dispatch model 经济调度模型 explore the direct coupling of deferrable consumers with renewable resources into a virtual resource through a contractual agreement based on a strike price that limits the impact of the coupled system on the rest of the network 探索了在限制耦合系统对于网络其他部分的影响的成交价下将可调性负载与可再生能源直接耦合接入虚拟。。。（不是很懂） Literature Review high investment cost of backup reserves 后备储能设施的投入来保证系统的可靠操作 quantifying reserve requirements as well as the impacts of renewable integration on operating costs 定量储藏要求和可再生能源对于运行损耗的影响 impact of renewable supply uncertainty on power system operations (focus) 可再生能源供应的不确定性对电力系统操作的影响 the potential benefits of demand response integration 一体化需求响应的潜在好处 ？ demand function 需求函数 However, many flexible consumption tasks are best characterized as deferrable, in the sense that consumers need a certain amount of energy within a certain time window. As such, deferrable demand behaves much like a hydro or storage resource from the view point of the system operator. Electric vehicle charging, agricultural pumping, pre-cooling, and residential consumption such as laundry fit this characterization. 为什么更像一个水电或者储存？农业泵，洗衣机为什么相似？ real-time pricing at the retail level 需要实时电价 volatility of wholesale electricity prices 批发电价的波动性 the non-convex costs of system operations 实时电价由于系统运行中的非凸成本（有绝对的需求时）不能表达出需求响应的经济价值 为什么是非凸的？ excessive startup and minimum load costs 上述问题会导致过多的启动和最小负载成本 the system operator dispatches the system at a bulk scale and cannot control individual retail loads 只能在大规模上，不能分布式 concerns about defining market products that correspond to the types of services that loads can actually offer, which raises the need for reform in existing electricity markets 需要对现有市场进行改革 Paper Contributions a stochastic unit commitment model that can be used in order to quantify the benefits of deferrable demand in mitigating the increased operating costs and day-ahead reserve requirements resulting from the random fluctuation of renewable energy supply 一个可以用来量化可延缓需求在减少增长的运行损耗和由于可再生能源的随机波动导致的提前一天的存储需求 The use of stochastic planning models for simulating long-term market equilibrium in order to quantify generation investment in the face of long-term uncertainty 用随机规划模型来模拟长期市场均衡以用来量化面对长期不确定性情况下的发电投资 used in order to simulate the two-stage operation of day-ahead and real-time electricity markets 用来模拟提前一天的二阶操作和实时的电力市场 computational challenges using an appropriate scenario selection technique to discretize the uncertainty space of the problem extend existing models by simultaneously modeling the inter-temporal dependency of deferrable demand and renewable supply uncertainty 跨时间段的依赖关系和可再生能源供给的随机性 present a contractual alternative for coupling the operations of renewable resources with deferrable demand that attempts to overcome the implementation barriers associated with centralized load dispatch and real-time pricing of retail loads, and compare the relative performance of each demand response paradigm in terms of system operating costs 展现了一个（（具备试图克服执行障碍和集中负载调度的可调需求的可再生资源的操作）与（基于零售负载的实时电价的耦合））的基于合同的替代选项，并且比较了在系统运行损耗中各个不同的需求响应模式的表现 MODEL OVERVIEW Uncertainty in the model is driven by renewable supply and demand. Demand resources in the system are categorized as inflexible (firm) consumers with stochastic consumption patterns and deferrable consumers that require a fixed amount of energy within the day and adapt their instantaneous consumption patterns to the prevailing system conditions. 把需求分为了两类，一类是固定用户，消耗模式随机，另一类是可调用户，需求固定，消耗模式适配到系统即时状态 The decision support module in the upper portion of the figure simulates day-ahead market operations and is used for determining day-ahead reserve requirements when deferrable demand contributes to absorbing the variability of renewable energy supply The evaluation module in the lower portion of the figure uses the reserves committed by the day-ahead model in order to compare the real-time operating costs of the system under the three demand response paradigms that are discussed in the introduction of the paper. Statistical Models We use a second order autoregressive model for modeling demand and load. 二阶自回归模型用来模拟需求和负载 固定需求与可再生能源产出是相互独立的（assumption） employ a data set published by NREL which provides time series of wind speed at various geographic locations over a year Yule-Walker equations Probability distribution function of inflexible demand In the present analysis we use a single-area wind model and ignore transmission constraints in order to focus on the impact of demand response. 在现在的分析中，我们使用了单个区域的风力模型并且为了集中于需求响应忽略了传递约束 （没做多个区域和考虑传递约束的） The problem of balancing the schedules of coupled resources with the rest of the system while respecting transmission constraints would be addressed by the system operator and would be reflected in locational marginal prices from the point of view of aggregators. 在考虑传递约束的情况下，平衡耦合资源规划与系统其他部分的问题会有系统操作员来解决，并且从聚合的角度来看 ？，这个结果会反映在节点边际电价上 the aggregator can hedge by buying financial transmission rights ？ 购买输电权。。对冲 Stochastic Unit Commitment assumes that the system operator co-optimizes the dispatch of flexible loads and generation resources 假设系统操作员可以同时协调控制柔性负载与发电资源 two-stage decision model where the first stage represents day-ahead unit commitment and the second stage represents real-time economic dispatch in the hour-ahead market, in hourly intervals, subsequent to the realization of uncertainty 一个第一阶段表示日超前机组组合模型第二阶段表示由于不确定性的实现因而以一小时为间隔的时超前市场上的实时经济调度的二阶决策模型 操作员每小时能够计算出模型结果是基础 $S$ a discrete set of scenarios $G$ set of gengrators $G_s$ set of slow generators which commitment decisions are fixed in the day-ahead time frame $G_s\in G$, another part are fast generators that can adjust their commitment schedule in the second stage $w_{gt}$ First-stage decisions $z_{gt}$ the binary unit commitment and startup decisions for slow generators $u_{gst}$ the unit commitment of all generators $v_{gst}$ startup of all generators $p_{gst}$ power output of all generators $e_{st}$ The dispatch of deferrable loads (a second-stage decision variable) $S_{g}$ startup cost for each generator $K_g$ minimun load costs for each generator $C_g$ constant fuel costs for each generator $D_{st}$ net demand (the net of firm demand minus renewable power supply, represents the source of uncertainty) $\mathcal{D}$ includes generator capacity constraints, ramping constraints, and minimum up and down times, where bold fonts indicate vectors. - The objective function of (1) minimizes operating costs. - Power balance is enforced in (2). - The constraint of (3) requires that deferrable loads be supplied an amount of energy within a given time window. - (4) enforces a limit of on the consumption (e.g., charge) rate of deferrable loads. - The non-anticipativity constraints on first-stage decisions is enforced in (5). - all generators, including slow units, can adjust their production level in the second stage - The solution of the stochastic unit commitment model is described in detail by Papavasiliou [37] About scenario selection algorithm - scenarios are selected according to their effect on expected cost and weighed such that their selection does not bias the objective function of the stochastic unit commitment formulation 场景是根据他们各自对于期望损耗的效果来权衡保证选择与随机机组组合模型的目标函数无关 - The decomposition algorithm which is employed relies on a Lagrangian relaxation scheme for scenario decomposition. 分解算法基于拉格朗日松弛算法 - The centralized stochastic unit commitment model presented in this section presumes the ability of the system operator to centrally monitor and control individual loads.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F07%2F04%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
