<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[LabVIEW基础教程（一）]]></title>
      <url>%2F2018%2F06%2F21%2FLabVIEW%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1. LabVIEW 导航前面板 前面板是用户的显示界面 输入控件和显示控件 数值输入与显示控件分别为Numeric Control和Numeric Indicator 布尔输入与显示控件布尔数据类型表示只有两个值的数据，如 TRUE 和 FALSE、或 ON 和 OFF。 布尔控件输入控件和显示控件用于输入和显示布尔值。 布尔对象模拟开关、按钮和指示灯。分别为Boolean\Round LED和Boolean\...Toggle Switch 字符输入和显示控件分别为String Control、String Indicator、Ex Table 前面板窗口工具栏 程序框图窗口（Block Diagram） 接线端（可通过右键\visible items\terminals） 数据输入控件、显示控件和常量 通常先在前面板添加数据输入控件和显示控件，然后会直接显示在程序框图中，常量在程序框图中直接添加 子VI 子VI可以通过对已有框图部分选定直接建立新的子VI，或者直接建立VI，然后鼠标拖动过去，需要在子VI右上角的接线板上设定端口，设定方式为在子VI前面板中先左键点一下接线板上的端口，然后点一下对应想绑定的控件 连线类型 连线时注意连线于接线端颜色相同按Ctrl-B可以删除框图中的所有断线 程序框图工具栏 数据流对于如图的多段代码，无法知道具体的执行顺序，后续可以通过错误簇来设定执行顺序 创建一个简单的VI（使用Express VI） 数据采集控件 数据分析控件 数据显示控件 2. 疑难解答和调试VI调试技术 用操作工具连续三次点击连线，可高亮整个路径，从而确保所有连线连接到正确的接线端使用断点中断以及探针实时查看数据、步进运行程序 错误检查和处理####自动错误处理 每个错误都有一个数值代码和相应的错误信息。 默认状态下， VI 运行时LabVIEW 会通过中断执行，高亮显示产生错误的子VI或函数，并显示错误对话框，自动处理每一个错误。选择文件» VI 属性，从类别下拉菜单中选择执行，可禁用当前VI 的自动错误处理。 选择工具» 选项，并在类别列表中选择程序框图，可以禁用任何新创建的空白VI 的自动错误处理。 如需禁用一个VI 中的子VI 或函数的自动处理错误功能，可将其错误输出参数与另一个子VI 或函数的错误输入参数连接，或连接到一个错误输出显示控件。 手动错误处理 错误簇 使用错误簇输入控件和显示控件创建子VI 中的错误输入和输出。 错误输入和错误输出簇包括以下部分信息： 状态是一个布尔值，错误产生时报告TRUE。 代码是一个32 位有符号整数，通过数值表示错误。 一个非零错误代码和FALSE 状态相结合可表示警告但不是错误。 源是用于识别错误发生位置的字符串。 LabVIEW 中的错误处理遵循数据流模式。 错误信息如同数据值一样流经VI。 错误信息从VI 的起点一直连接到终点。 错误处理VI 与VI 连接后可确定该VI 的运行是否产生错误。 使用或创建的每一个VI 中的错误输入和错误输出簇可用于在VI 中传递错误信息。VI 运行时， LabVIEW 会在每个执行节点检测错误。 如LabVIEW 没有发现任何错误，该节点将正常执行。 如LabVIEW 检测到错误，该节点会将错误传递到下一个节点并且不执行代码。 后面的节点也照此处理，直到最后一个节点。 在执行流结束时， LabVIEW 报告错误。 3. 实现VI数据类型数据数值类型浮点型:浮点型用于表示分数。 LabVIEW 中，用桔黄色代表浮点型。单精度(SGL):单精度浮点数为32 位IEEE 单精度格式。 使用单精度浮点数可节省内存并避免溢出。双精度(DBL):双精度浮点数为64 位IEEE 双精度格式。 双精度为数值对象的默认格式。 大多数情况下都使用双精度浮点数。扩展精度(EXT):在内存中，扩展精度数的字长和精度随所在平台的不同而不同。 在Windows 中，扩展精度数为80 位IEEE 扩展精度格式。 整型:整型用于表示整数。 有符号整型可以是正数也可以是负数。 无符号整型用于表示正整数。 LabVIEW 中，用蓝色代表整型。LabVIEW 将浮点数转换成整数时，VI 会对其四舍五入并转换为最接近的偶数。例如， LabVIEW 将2.5 舍入为2，将3.5 舍入为4。字节(I8):单字节整数占8 位存储空间。字(I16):双字节整数占16 位存储空间。长整型(I32):长整型数占32 位存储空间。 大多数情况下，最好使用32 位的长整型。64 位整型(I64):64 位整型数占64 位存储空间。 复数:复数由内存中两个相连的数值表示：一个表示实部，一个表示虚部。 由于复数属于浮点数的一种，所以LabVIEW 中也用桔黄色代表复数。单精度复数:单精度浮点型复数由32 位IEEE 单精度格式的实数和虚数构成。双精度复数:双精度浮点型复数由64 位IEEE 双精度格式的实数和虚数构成。扩展精度复数:扩展精度浮点型复数由IEEE 扩展精度格式的实数和虚数构成。在内存中，扩展精度数的字长和精度随所在平台的不同而不同。 在Windows中，扩展精度数为80 位IEEE 扩展精度格式。 布尔值LabVIEW 用8 位二进制数保存布尔型数据。 如8 位的值均为0，布尔值为FALSE。 非零值表示TRUE。 在LabVIEW 中，用绿色代表布尔型数据。 布尔值还有一个与其相关的机械动作。 触发和转换是两种主要的机械动作。 触发动作与门铃的动作方式类似；转换动作与照明灯开关的动作方式类似。 触发和转换动作各有3 种发生方式：单击时，释放时，保持直到释放。 关于机械动作的更多信息见“NI 范例查找器”中的Mechanical Action of Booleans VI。 字符串字符串是可显示的或不可显示的ASCII 字符序列。 字符串可以提供与平台无关的信息和数据的格式。 常用的字符串应用包括： 创建简单的文本信息。 将数值数据以字符串形式传送到仪器，再将字符串转换为数值。 将数值数据存储到磁盘。 如需将数值数据保存在ASCII 文件中，必须在数值数据写入磁盘文件前将其转换为字符串。 用对话框向用户显示提示信息。 前面板上的表格、文本输入框和标签中都会出现字符串。 LabVIEW 提供了用于对字符串进行操作的内置VI 和函数，可对其进行格式化字符串、解析字符串等编辑操作。 枚举型（Enum） 动态数据类型（DDT） While 循环LabVIEW中的While循环实际上是do–While, 意味着无论判断条件如何，循环语句将会至少执行一次 计数从0开始 For 循环 VI设置定时等待函数 已用时间 迭代数据传递移位寄存器通过右键单击循环的左侧或右侧边框，从快捷菜单中选择Add Shift Register 初始化移位寄存器重新运行时会重置参数 未初始化的移位寄存器重新运行时会继承参数 层叠移位寄存器可以理解为左侧形成了一个队列在上面进行插入，下面进行删除 数据绘图波形图表图 可以配置图表更新数据的方式。 右键单击图表，从快捷菜单中选择高级» 更新模式，可配置图表的更新模式。 图表显示数据的模式有如下几种： 带状图表－从左到右连续滚动地显示运行数据，旧数据在左，新数据在右。 带状图表类似于纸带图表记录器。 带状图表是默认的更新模式。 示波器图表－显示某一项数据，如脉冲或波形，并从左到右地滚动图表。图表将新数值绘制到前一个数值的右边。 当曲线到达绘图区域的右边界时， LabVIEW 将擦除整条曲线并从左边界开始绘制新曲线。 示波器图表的这种回扫显示特性类似于示波器。 扫描图－类似于示波器图表，不同之处在于扫描图表中有一条垂直线将右边的旧数据和左边的新数据隔开， 而且当曲线到达绘图区域的右边界时，扫描图表中的曲线不会被擦除。 扫描图表的显示特性类似于心电图仪(EKG)。 使用Bundle函数可以在波形图表中显示多条曲线 条件结构 如果输入选择器的值与选择器接线端连接的对象不是同一数据类型，该值将变为红色，表示在执行前必须删除或编辑该值，否则VI 不能运行。 同样，由于浮点运算存在固有的舍入误差，因此浮点数不能作为条件选择器的值。如果将一个浮点值连接到条件分支， LabVIEW 将对其进行四舍五入，变为最接近的偶数值。 如果在分支选择器标签中输入浮点值，数值将变成红色，表示在执行结构前必须删除或编辑该值。 条件结构范例 布尔型条件结构 整型条件结构 字符串型条件结构 枚举型条件结构 使用条件结构处理数据 公式节点(Formula Node)公式节点是一种便于在程序框图上执行数学运算的文本节点。 用户无须使用任何外部代码或应用程序，且创建方程时无须连接任何基本算术函数。除支持文本方程表达式外，公式节点还支持为C 语言编程者所熟悉的if 语句、while 循环、for 循环和do 循环的文本输入。 这些程序的组成元素与C 语言程序相似，但并不完全相同。公式节点尤其适用于含有多个变量或较为复杂的方程，以及对已有文本代码的利用。 可通过复制、粘贴的方式将已有的文本代码移植到公式节点中，无须通过图形化编程的方式再次创建相同的代码。右键单击公式节点的边框，从快捷菜单中选择添加输入或添加输出，为公式节点创建输入接线端和输出接线端，然后在输入或输出中输入变量。 在结构中输入方程。 每一个方程表达式都必须以分号(;) 结尾。 4. 相关数据数组(Array)限制 不能创建嵌套数组，但是可以创建多维数组 创建数组输入控件和显示控件先在前面板上创建一个数组外框Array， 然后将一个数据对象或元素拖放到该数组外框中，数据对象或元素可以是数值、布尔值、字符串、路径、引用句柄、簇输入控件或显示控件。 在使用程序框图之前必须先在数组外框中插入一个对象 二维数组如需在前面板上创建一个多维数组，右键单击索引框，从快捷菜单中选择Add dimension。 也可以改变索引显示框的大小，直至出现所需维数。 自动索引数组输出默认情况下While循环已经禁用自动索引 创建二维数组 簇(Cluster)簇将不同类型的数据元素归为一组。 簇元素顺序尽管簇和数组元素都是有序的，但如需访问特定簇元素，必须一次拆分所有簇元素或使用“按名称解除捆绑”函数。 簇不同于数组的地方还在于簇的大小是固定的。 与数组一样，簇中应只包含输入控件或显示控件。 簇不能同时含有输入控件和显示控件。 创建簇输入控件和显示控件在前面板窗口上添加一个簇外框，再将一个数据对象或元素拖曳到簇外框中，数据对象或元素可以是数值、布尔、字符串、路径、引用句柄、簇输入控件或簇显示控件。 放置簇外框时，通过拖曳光标可以改变簇的大小。 簇不能同时包含显示控件和输入控件 簇元素顺序簇元素有自己的逻辑顺序，与它们在外框中的位置无关。放入簇中的第一个对象是元素0，第二个是元素1，依此类推。 如果删除某个元素，该顺序会自动调整。 簇顺序决定了簇元素在程序框图上的“捆绑”和“解除捆绑”函数上作为接线端出现的顺序。 右键单击簇边框，从快捷菜单中选择重新排序簇中控件，可查看和修改簇顺序。 使用簇函数 集合簇使用Bundle函数 修改簇 如果知道簇的顺序，通过“捆绑”函数对图5-19 中所示的元素进行连线，可改变命令控件的值。“按名称捆绑”函数也可替换或者访问现有簇中带标签的元素。 “按名称捆绑”函数的工作方式同“捆绑”函数类似，但是它以自身标签为引用，而不是其在簇中的顺序。 只有带标签的元素可以被访问。 输入的个数不需要与输出簇中元素的个数相匹配。使用操作工作单击一个输入接线端并在下拉菜单中选择一个元素。 也可以右键单击输入端，从选择项快捷菜单中选择元素。 分解簇 “解除捆绑”函数用于将簇分解为单个元素。“按名称解除捆绑”函数用于根据指定的元素名称返回单个簇元素。 输出接线端的个数不依赖于输入簇中的元素个数。使用操作工作单击一个输入接线端，从下拉菜单中选择一个元素。 也可以右键单击输出接线端，从选择项快捷菜单中选择元素。 自定义类型自定义控件详细看LabVIEW帮助中的创建自定义输入控件、显示控件和自定义类型主题 自定义类型 5. 存储测量数据理解文件I/O文件格式LabVIEW 可以使用的文件格式：二进制、ASCII、LVM、TDM 二进制－二进制文件是基本文件格式，是所有其它文件格式的基础。 ASCII － ASCII 文件是一种特定类型的二进制文件，是大多数程序使用的标准。 它包含了一系列ASCII 码。 ASCII 文件也称为文本文件。 LVM－LabVIEW数据文件(.lvm)是用制表符分隔的文本文件，可以用电子表格应用程序或文本编辑应用程序打开。 .lvm 文件包括了数据的信息，例如，生成数据的日期和时间。 这种文件格式是一种特定类型的ASCII 文件，专用于LabVIEW。 TDM －这种文件格式是一种特定类型的二进制文件，专用于NI 产品。 它实际上包含了两个单独的文件：包含数据属性的XML 文件和用于表示波形的二进制文件。 LabVIEW 数据目录通过选择tools-&gt;options-&gt;paths 可以指定其他默认数据目录。 理解高层文件I/O高层文件I/O:可以执行一个文件I/O操作流程中的所有三项操作：打开、读/写、关闭的文件I/O VI。 如果正在写入位于循环中的文件，可以使用底层文件I/O VI。如果正在写入单个操作中的文件，则使用高层I/O。避免将高层VI放入循环中，因为这些VI在每次运行时都要进行打开关闭操作。主要查看File I/O 底层文件I/O每个底层文件I/O VI 核函数都只执行文件I/O操作流程中的一个操作。 使用底层函数的流盘流盘:在进行多次写操作时保持文件打开的技术 6. 开发模块化应用程序子VI的创建详见程序框图窗口（Block Diagram）。 7. 数据采集模拟一个DAQ设备在存在DAQ设备时，可以使用NI MAX(Measurement &amp; Automation Explorer)配置，没有设备时可以使用NI MAX模拟一个。 创建NI-DAQmx模拟设备按照下列步骤创建一个NI-DAQmx 模拟设备： 展开Devices and Interfaces。 右键单击NI-DAQmx Devices，并选择Create New NI-DAQmx Device»NI-DAQmx Simulated Device。 在Choose Device 对话框中选择所需模拟设备的设备系列。 选择设备并单击OK。 如果选择了PXI 设备，会提示选择一个机箱号和PXI 插槽号。 如果选择了SCXI 机箱， SCXI 配置面板就会打开。 删除NI-DAQmx模拟设备请按以下步骤删除一个NI-DAQmx 模拟设备： 展开Devices and Interfaces»NI-DAQmx Devices。 右键单击需要删除的NI-DAQmx 模拟设备。 单击Delete。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SikuliX]]></title>
      <url>%2F2018%2F06%2F21%2FSikuliX%2F</url>
      <content type="text"><![CDATA[Sikuli ScriptTo get debug output, if you use the SikuliX apps or otherwise have no chance to set parameters:before starting add an empty file named SikulixDebug.txt in your home folder. This is detected and will internally switch to running with -d 3 -c and redirect all debug output to this file. The debug level can also be set inline in scripts and code… and will be used from this point on until switched off or reset to another value Debug.on(3) — switch debugging on with level 3 Debug.off()— switch debugging off general aspect of scriptingBelow is an Example of SikuliX script in Python: 12345678910while True: # repeat the body forever wait("image1.png", 10) # wait max 10 seconds for image1 to get visible, otherwise die click("button1.png") # click the button given by image button1 if exists("image2.png"): # wait max 3 seconds for image2 to get visible, return True or False doSomething() # in case True execute function doSomething (defined somewhere else) else: break # in case False get out of the loop, which ends the workflow # start all over with the line after the while# the end of the workflow Where and how can a SikuliX script be storedA SikuliX script consists of one file containing the statements of your scripted workflow and zero to many image files, that you have captured, to support your workflow. This bunch of related files is meant when we talk about a SikuliX script. How to run such a script is shown in the next chapter. The standard storage for a SikuliX script is a folder/directory having the name that you have given to the script, when saving it from the IDE. It is mandatory, that the contained script file has the same name as the folder, which is guaranteed, when working with the SikuliX IDE. To avoid any problems, you should never directly access the folder content outside the SikuliX IDE, except you really know, what you are doing. The file structure is like below: 12345myscript.sikuli button1.png image1.png image2.png myscript.py There are two other storage variants for SikuliX scripts: zip-file and jar-file, which are intended for distribution of your scripts. Both variants pack the SikuliX script content in one file, which makes distribution easier. Both variants can be run with the means of SikuliX, as long as the target system has a valid SikuliX installation/setup. variant zip-file It can be created in the SikuliX IDE with the file menu entry Export packed source and gets the ending.skl instead of .sikuli. As such it cannot be reopened for editing nor used for import, it can only be run using SikuliX features on systems having a valid SikuliX setup. In fact it is simply a zip-file, which can be brought back to a .sikuli folder using a zip utility. So be aware, that this variant does not really hide your script content. variant jar-file (only available in 1.1.2+) It can be created in the SikuliX IDE (file menu entry Export as jar). It can be run using SikuliX features on systems having a valid SikuliX setup. The script source is contained in compiled form (Java byte code) and hence not visible, even if one accesses the jar content. So this variant gives some level of secrecy for your scripted workflow. There is a sub-variant, containing the scripting and SikuliX feature support additionally to the script content, which makes it runnable even on systems not having a valid SikuliX setup, but only a valid Java installation. Be aware, that such a jar has at least 60 MB though. How to make and use it look here. How to Run a SikuliX scriptIn the SikuliX IDE a currently open script in the front most editor tab can be run by clicking the run button. Saved scripts (.sikuli) and exported scripts (.skl and .jar) can be run from command line(see) or from within other scripts (see). Using PythonSetup a Jython environmentApply the following steps, to get a Jython environment, that is SikuliX aware: download the installer package from Jython Downloads install (usually by double-clicking the package) using the standard setup into an empty folder test by running &lt;jython-folder&gt;/bin/jython from a command line, which should open an interactive Jython session, that allows, to run Python statements line by line make sure, that pip and easy_install are available: &lt;jython-folder&gt;/bin/pip exists &lt;jython-folder&gt;/bin/easy_install exists if this is not the case run &lt;jython-folder&gt;/bin/jython -m ensurepip on a command line and check again if you do not get pip ready, don’t bother: Jython is useable without it. The caveat: any additional packages have to be installed/setup manually. If you succeeded with pip: run &lt;jython-folder&gt;/bin/pip install jip to install the package jip, which allows to add Java libraries easily to your Jython environment add any needed Python package (must not depend on C-based stuff) using pip, easy-install or manual methods into&lt;jython-folder&gt;/Lib/site-packages and/or use jip for adding Java libraries preferably from Maven Central Access Python packages from SikuliX scripts run by SikuliX (GUI or command line)The following approaches apply to situations, where you want to use Python modules installed somewhere on your system, without the need to manipulate sys.path, meaning, that when using ìmport moduleXYZ this package is found automatically. SikuliX uses a central repository (SikulixRepo in the following) for internal stuff (native libraries, downloaded artifacts, resources needed at runtime and similar things). This is a folder in the user’s private space (home folder) look here: Windows: %APPDATA%\Sikulix Basic preparationTo SikulixRepo add a folder Lib (if not already there) and inside add a folder site-packages Approach 1Since an existing folder SikulixRepo/Lib/site-packages will be recognized and added automatically as the 1st entry to sys.path, modules/packages contained in here will be found when imported without any further preparations. This approach can be used, to “overwrite” modules/packages, that otherwise would be found elsewhere on sys.path (e.g. for testing) Approach 2In the folder SikulixRepo/Lib/site-packages have a file sites.txt, that contains absolute paths one per line, that point to other places, where modules packages can be found. These paths will be added automatically at startup to the end of sys.path in the given sequence. With this approach, you might for example add the Lib/site-packages folder of your own Jython installation. Prepare and use your own jar files in the Jython environmentYou might prepare jar files containing Python scripts/modules/packages, Java classes and other stuff like images, that are intended to be used in the scripting context. possible use case you want to pack scripted stuff together with other resources into a container ready to be used by yourself or others via import (which is not supported by the .skl packaging method). you want to secure your script code against modifications by others, that use your distributed jar. Later (possibly only with version 2) there will be a feature available, to run such script containers directly from command line (java -jar mystuff.jar parameters) or by double clicking. typical jar file structure1234567891011121314-- jar rootlevelmodule1.py # Python modulemodule2.py- folder1 # Python package __init__.py stuff1.py stuff2.py- images # image folder img1.png img2.png- org # Java package - mystuff class1.class class1.class how to pack such a jarYou might use the Java jar utility (contained in the JDK). Or use the SikuliX provided feature Sikulix.buildJarFromFolder(jarpath, folder), where jarpath is the absolute path to the jar (the parent folder must exist, the jar is overwritten), that should be created and folder is the absolute path to a folder, containing the stuff to be packed. The content of the folder is copied to the root of the created jar. Just run Sikulix.buildJarFromFolder(jarpath, folder) in an empty tab in the IDE or in a script, that might do some pre- and/or post processing. If the folder contains an __init__.py on the first level, the given folder is taken as a Python package and as such copied to the root level of the jar, to preserve the package context: 123456789-- packagefolder __init__.py stuff.pybecomes a jar-- jar rootlevel- packagefolder __init__.py stuff.py how to secure your script code using the jar packaging step 1: prepare a folder as in the previous chapter Step 2: compile the folder into a new folder (see below) Step 3: pack the new folder into a jar for distribution Run in an empty IDE tab or as part of a script: Sikulix.compileJythonFolder(sourcefolder, targetfolder) copies the complete content from source folder to target folder (the parent folder must exist, the folder is emptied if exists) and then traverses the target folder replacing each foobar.py with it’s compiled version foobar$py.class, that contains JVM-byte-code, so your script code cannot be edited anymore in this target folder, but still be used with import foobar. Be aware: Be sure, your code compiles without errors, because the compile feature either succeeds or fails (compile errors), but you will not get any information about the cause or even the place of the compile problem. Scripting with IntelliJ PyCharm and IDEA with Python pluginPyCharm has a weakness, in that code completion while editing does not look into jar-files nor Java classes, while in the built-in Python console after having imported a Java class, code completion about the class attributes/methods works, so having a console open while editing might help as a workaround for inspecting Java classes. Step 1: get Jython up and running Just follow the steps mentioned in the chapter Setup a Jython environment above. Step 2: get PyCharm up and running Download and install the PyCharm Community Edition. Step 3: tell PyCharm to use Jython as interpreter Start PyCharm and make sure to have closed all projects and be in the start-up window titled Welcome to PyCharm. At bottom right in the menu Configure select Preferences. You should get a dialog window titled Default Preferences. At the left side select Project Interpreter and choose your installed Jython by pointing to the contained .../bin/jython script/command-file. Click Apply and watch how the Jython setup is analyzed and implemented in PyCharm. If it worked click Ok. Step 4: setup the environment for a Python console As with the step before get the Default Preferences dialog open. At the left side select Build, Execution, Deployment… Console… Python Console. To the Environment variables add entry CLASSPATH, that points to a valid sikulixapi.jar (created using setup). In the Starting script you might add the 2 lines import org.sikuli.script.SikulixForJython from sikuli import * so each time you start a console, the prompt is already prepared to know about SikuliX features. Using RobotFrameworkYou can run ready Robot scripts out of the box in the SikuliX context (IDE or from command line). The needed Python module robot ( from robotframework 3.0 ) is bundled with the sikulixapi.jar. At runtime and already with setup, the module is exported to the folder &lt;SikulixAppData&gt;/Lib, which is on sys.path automatically. So there is no need to have anything else available than a suitable setup of SikuliX. The easiest way is to use the SikuliX IDE with this principal setup 12345678910111213141516171819202122232425262728runScript("""robot*** Variables ***$&#123;USERNAME&#125; demo$&#123;PASSWORD&#125; mode$&#123;TESTSITE&#125; http://test.sikuli.de*** Settings ***Library ./inline/LoginLibraryTest Setup start firefox and goto testsite $&#123;TESTSITE&#125;Test Teardown stop firefox*** Test Cases ***User can log in with correct user and password Attempt to Login with Credentials $&#123;USERNAME&#125; $&#123;PASSWORD&#125; Status Should Be AcceptedUser cannot log in with invalid user or bad password Attempt to Login with Credentials betty wrong Status Should Be Denied""")class LoginLibrary(object): def start_firefox_and_goto_testsite(self, page): popup("start_firefox_and_goto_testsite") def stop_firefox(self): popup("stop_firefox") def attempt_to_login_with_credentials(self, username, password): popup("attempt_to_login_with_credentials") def status_should_be(self, expected): popup("status_should_be") the first 2 lines 12runScript("""robot signal, that you want to run an inline Robot script, that follows on the next lines terminated by &quot;&quot;&quot;). This construct is a multiline Python comment, that can be used as a string. BE AWARE In the standard, a report HTML will be automatically opened in the standard browser at termination. If you do not want that (e.g. in unattended situations) use this instead as the first 2 lines. Take care: after robot 1 space, a linefeed directly after silent and nothing else. 12runScript("""robot silent Normally when working with SikuliX features, you have to do some Robot Keyword implementation at the Python level. To Robot you tell where to find these implementation using the Library setting. In this case we have the implementations inline in the same script file according to the Robot rules packed into a Python class having the Keyword methods according to the Robot naming conventions. At runtime this class will be exported to a Python file, whose absolute path is then replacing the Library setting. If you have the Keyword implementations somewhere outside, then you have to put the correct path specification into the Library setting. Another option is to reference a jar file as a Library again according to the Robot specifications. If you now run the script in the IDE, internally a robot.run will be fired after having setup the script content and the environment. Currently no extra options can be provided for the robot run. As a result you get a folder with the ending .robot named as your script in the same folder as your script folder containing inputs to and the results from the robot run 12345678# supposing the script is named testrobot.sikuli# then you get a folder testrobot.sikuli.robot with the contenttestrobot.robot # the robot scriptLoginLibrary.py # the Python Keyword implementations# the standard Robot outcomeoutput.xmllog.htmlreport.html Still being in the IDE another possible setup would be this way: 123456789101112131415161718192021222324robotScript = """robot*** Variables ***$&#123;USERNAME&#125; demo$&#123;PASSWORD&#125; mode$&#123;TESTSITE&#125; http://test.sikuli.de*** Settings ***Library /some/path/to/LoginLibrary.pyTest Setup start firefox and goto testsite $&#123;TESTSITE&#125;Test Teardown stop firefox*** Test Cases ***User can log in with correct user and password Attempt to Login with Credentials $&#123;USERNAME&#125; $&#123;PASSWORD&#125; Status Should Be AcceptedUser cannot log in with invalid user or bad password Attempt to Login with Credentials betty wrong Status Should Be Denied"""# here you could do some preprocessing and even modify the above robotscriptrunScript(robotscript)# eventually do something with the result BE AWARE for the keyword library, the Name in the file name Name.py and the statement class Name() must be the same and start with an uppercase letter. BE AWARE ON WINDOWS the file path must be escaped with 4 backslashes for each backslash like so C:\\\\Robot\\\\Libraries\\\\Name.py (which leads to the needed 2 backslashes for each backslash as escape in the final robot file) I think two backslashes are just enough. Of course you can use any other method, to fill a string representing a valid Robot script, provided the first line contains the string robot and only that (denoting the script type for run Script). If in such a case you want to provide an inline Keyword implementation: this does the trick: 1234567# prepare your script contentrunScript("robot\n" + scriptContent)# eventually do something with the result# """)# the rest is taken as inline Keyword implementation If you have the need to specify extra parameters to the robot.run(), then you still have the option to stay within the SikuliX context (IDE or from command line): 12345678prepareRobot() # takes care for the correct environmentworkdir = getParentFolder()script = "arobottest/arobottest.robot"robotscript = os.path.join(workdir, script)print "*** trying to run:", robotscriptrobot.run(robotscript, outputdir=workdir) A library.py file being either in the script folder itself or in the folder containing the script folder is found automatically. So simply the library name is enough in this case. In all other cases you either have to specify the absolute path off the .py script (take care with windows - see above) or use addImportPath() to add the folder containing the library.py file to sys.path, in which case again only the name is sufficient in the Robot script. It is strongly recommended, to always specify the outputdir= parameter since otherwise the report files will be written to the working folder (from where you are running), which might not always be what you want. If you want to use any of these variants outside the SikuliX context (some external Jython or in an IDE like PyCharm) you have to add these 2 lines at the beginning of your main script (as always in such cases): 12import org.sikuli.script.SikulixForJythonfrom sikuli import * to get the SikuliX context ready.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EESM 5650 L1 Introduction]]></title>
      <url>%2F2017%2F09%2F04%2FEESM-5650-L1-Introduction%2F</url>
      <content type="text"><![CDATA[L1 Intrductionnetwork consists essentially of network switches, or nodes, interconnected by transmission links. Key operating parameters: frequence: 2.4Ghz/5GHz (WiFi) Band Width: 20MHz Key tecxhnologies: OFDM（Orthogonal Frequency Division Multiplexing），MIMO（Multiple Input Multiple Output） Different types of networks Local Area Network (LAN) Metropolitan Area Network (MAN) Wide Area Network (WAN) Communication Systems and NetworksProtocol Architectures most networks are designed as a series of layers or levels: each one built upon its predecessor. the goal of each layer is to offer certain services to the higher levels, shielding those layers from the details of how the offered services are actually implemented. Layer N on one host carries on a conversation with layer N on another host. The rules and conventions used in this conversation or session are collectivelyknown as the layer N protocol. ISO’s OSI Reference ModelISO’s OSI Reference Model consists 7 Layers Internet Protocol Stack application: supporting network applications : HTTP, SMTP, FTP, DNS transport: process-process data transfer: TCP, UDP network: routing of datagrams from source to destination: IP, routing protocols link: data transfer between neighboring network elements: 802.11, Ethernet physical: bits “on the wire” link layer: bits—&gt;packets—&gt;correct errors physical layer: sending bits from A —&gt; B network layer: join nodes together How Layer Works Each layer adds/strips off its own header (and possibly a trailer) Each layer may split up higher-level data Each layer multiplexes multiple higher layers Each layer is (mostly) transparent to higher layers Encapsulation Transmission Protocols Simplex（单工）：Communication flow can only occur in one direction Half Duplex（半双工）：Communication flow can occur in both directions, but not at the same time Full Duplex（全双工）：Communication link can support simultaneous two-way communications.（requires twice channels of Simplex or half-duplex） Transmission SystemsAnalog Communications Continuous modulation Fidelity is usually defined in terms of SNR $$ SNR={P_S \over P_N} $$$$ dB=10log{P_S\over P_N} $$When SNR&gt;10dB====&gt; Good Communications Digital Communications Signals made up of discrete symbols selected from a finite set Fidelity or Accuracy is specified in terms of bit error rate ( BER ) mobile out: 0.1Wmobile in: $10^{-10}W\sim 10^{-13}W$mobile noise: around $10^{-13}W$ Digital Communication Systems Sampling Quantization Source Coding Encryption Channel coding Modulation Communication ChannelsEffects include: Attenuation Noise Filtering Fading Time Variation Good Commnication System Small signal power (measured in Watts or dBm) Large data rate (measured in bits/sec) Small bandwidth (measured in Hertz) Low distortion (measured in SNR or bit error rate) Low cost - with digital communications, large complexity does not always result in large cost Stochastic ProcessStatistical Description of Noise Generally noise can be modeled as a Gaussian process (by the central limit theorem). In this case, we say that at a particular time, t, the noise signal amplitude will be Gaussian distributed If the noise is white noise, then all frequency components appear with equal power (white used in white light for similar reason) Statistical Averagesdiscrete: $$\bar {X}=E[X]=\sum_{i=1}^M x_iP_i$$ continuous: $$\bar {X}=E[X]=\int_{-\infty}^{\infty}xf_X(x)dx$$ Variance $$\sigma_X^2=E[(X-\bar{X})]=E[X^2]-(E[X])^2$$ $\sigma_X$= Standard Deviation Joint Distribution $$F_{XY}=(x,y) \triangleq P(X\le x, Y\le y)$$ $$f{XY}(x, y)={\partial^2 F{XY}(x, y)\over {\partial x\partial y}}$$ If X and Y are said to be independent, $$P(X\le x, Y\le y)=P(X\le x)P(Y\le y)$$ Key DistributionGaussian Distribution $$X\sim N(m_X, \sigma^2_X)$$ $$f_X(x)={1\over {\sqrt{2\pi\sigma_X^2}}}exp(-{(x-m_X)^2\over {2\sigma^2_X}})$$ Zero Mean CorrelationCorrelation: the dependency between 2 entities Random Process A random process is a rule assigning every outcome of an experiment a function X(t) A random process can be described as X(t)=x(t,n) where n is a member in the sample space S A particular X(t)=x(t,n) is referred to as a sample function or realization of the random process A random process is said to be Wide-Sense Stationary (WSS) If and Only If $$E[X(t)]\triangleq \bar{X}(t)=Constant$$ $$R_X(t_1, t_2)=E[X(t_1)X(t_2)]=R_X(|t_1-t_2|)\triangleq R_X(\tau)$$ That is, a WSS process is characterized by a constant mean and a one-dimensional autocorrelation function that depends on only the time difference t Autocorrelation The autocorrelation of a random process describes the correlation between values of the process at different times It is a function of the two times for which the values are found $$R_X(t_1,t_2)=E[X(t_1)X(t_2)]$$ Typically as the difference between the two times gets larger the auto-correlation gets less for white noise: Autocorrelation = 0 Time Averages A r.p. is said to be Ergodic if all time averages and Ensemble averages are equal Noise Power = $KT\times B$$$dBW=10log(KTB/1W)$$ $$dB=10log({P_1\over P_2})\dBW=10log({P_1 \over 1W})\dBm=10log({P_1 \over 1mW})$$ SummaryNoise: Gaussian Ergodic-&gt;Stationary mean-&gt;Zero mean PSD-&gt;(FT)Autocorrelation]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[EESM 5620 L1 Introduction]]></title>
      <url>%2F2017%2F09%2F04%2FEESM-5620-L1-Introduction%2F</url>
      <content type="text"><![CDATA[EESM 5620 Flat DisplayL1 IntroductionChapter 1 Introduction1.1 Background Knowledge materials science electronics optics 1.2 Various kinds of displaysInformation displays: Fixed displays （指针显示器？） Electronic displays （电子显示器） Emissive （主动发光） Neon light signs Cathode ray tube (CRT) 阴极射线显像管 Light emitting diode (LED) 发光二极管 Electroluminescent display (ELD) 电致发光显示器 Plasma display panels (PDP) 等离子显示板 Vacuum fluorescent display (VFD) 真空荧光显示屏（类似电子管） Field emission display (FED) 场发射显示器 Organic LED (OLED) 有机发光二极管 Polymer LED (PLED) 高分子发光二极管 Non-emissive (based on control of light transmission or reflection) 被动发光（基于光的传输和反射的非发射性？） Mechanical tile displays Liquid crystal display (LCD) 液晶显示器 Microelectromechanical (MEMS) based display (DMD or DLP) 微机电系统显示器 Electrochromic display (ECD) 电致变色显示器 Electronic ink (e-ink) 电墨显示器 But the market is dominated by CRT and LCD. LCD technology is further subdivided into TN, STN, TFT (active matrix) etc. TN = Twisted nematic（扭曲向列型）. STN = Supertwisted nematic（超扭曲向列屏）. TFT = Thin film transistor（薄膜晶体管）. A projection display system consists of imager（成像器） + color management optics（光学色相。。） + projection lens（投影透镜） + screen （屏幕） Chapter 2 Basic Structure of LCD2.1 Basic Structure AND Materials 2.2 Basic operating principlespolarization manipulation of light using electrical pulses Common model of a TN display: 2.3 Different ways to view a LCD Transmittive（透射）: This is often the case for LCD with backlighting（no reflector）. Transflective（半透）: The rear reflector is often a diffusive type reflector to eliminate mirror effects. Reflective（全反射）: In a truly reflective LCD, there is only one front polarizer.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多维混合Copula的风速建模]]></title>
      <url>%2F2017%2F04%2F13%2F%E5%A4%9A%E7%BB%B4%E6%B7%B7%E5%90%88Copula%E7%9A%84%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[多维混合Copula参数估计EM算法主体部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122ticU=QWC;V=BDQC;Z=GHKC;M=CMC;%初始化S=5;th=0.001omega=[1/5,1/5,1/5,1/5,1/5];a1=copulafit('Gaussian',[U,V,Z,M]);[a2,nuhat]=copulafit('t',[U,V,Z,M]);a3=copula4fit('Gumbel',[U,V,Z,M]);a4=copula4fit('Clayton',[U,V,Z,M]);a5=copula4fit('Frank',[U,V,Z,M]);theta=&#123;a1,a2,a3,a4,a5&#125;;tturntheta_old=zeros(35,1);N=numel(U);count=0;tt=zeros(N,4);nn=zeros(N,4);tt(:,1)=tinv(U(:),nuhat);tt(:,2)=tinv(V(:),nuhat);tt(:,3)=tinv(Z(:),nuhat);tt(:,4)=tinv(M(:),nuhat);nn(:,1)=norminv(U(:));nn(:,2)=norminv(V(:));nn(:,3)=norminv(Z(:));nn(:,4)=norminv(M(:));t=inf;COPULA=zeros(N,S);list1=cell(6,101);list2=zeros(5,101);puz=zeros(N,S);puz1=zeros(N,S);turntheta_old=zeros(15,1);lower=[-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,-inf,1.001,0.001,-inf];turntheta=zeros(15,1);while t&gt;=th&amp;&amp;count&lt;=100 theta_old=theta; omega_old=omega;%保证搜索过程中仍为正定矩阵 [A1,B1]=eig(theta_old&#123;1&#125;); [A2,B2]=eig(theta_old&#123;2&#125;); C1=A1*sqrt(B1); C2=A2*sqrt(B2); tturntheta_old(1:16)=reshape(C1,[16,1]); tturntheta_old(17:32)=reshape(C2,[16,1]); tturntheta_old(33)=theta_old&#123;3&#125;; tturntheta_old(34)=theta_old&#123;4&#125;; tturntheta_old(35)=theta_old&#123;5&#125;; COPULA(:,1)=copulapdf('Gaussian',[U,V,Z,M],theta_old&#123;1&#125;); COPULA(:,2)=copulapdf('t',[U,V,Z,M],theta_old&#123;2&#125;,nuhat); COPULA(:,3)=copula4pdf('Gumbel',[U,V,Z,M],theta_old&#123;3&#125;); COPULA(:,4)=copula4pdf('Clayton',[U,V,Z,M],theta_old&#123;4&#125;); COPULA(:,5)=copula4pdf('Frank',[U,V,Z,M],theta_old&#123;5&#125;); puz(:,1)=COPULA(:,1)*omega_old(1); puz(:,2)=COPULA(:,2)*omega_old(2); puz(:,3)=COPULA(:,3)*omega_old(3); puz(:,4)=COPULA(:,4)*omega_old(4); puz(:,5)=COPULA(:,5)*omega_old(5); for i=1:N puz1(i,1)=puz(i,1)/sum(puz(i,:)); puz1(i,2)=puz(i,2)/sum(puz(i,:)); puz1(i,3)=puz(i,3)/sum(puz(i,:)); puz1(i,4)=puz(i,4)/sum(puz(i,:)); puz1(i,5)=puz(i,5)/sum(puz(i,:)); end omega(1)=sum(puz1(:,1))/N; omega(2)=sum(puz1(:,2))/N; omega(3)=sum(puz1(:,3))/N; omega(4)=sum(puz1(:,4))/N; omega(5)=sum(puz1(:,5))/N; omega [tturntheta,fval,exitflag,output]=update4theta(N,U,V,Z,M,tturntheta_old,puz1,tt,nn,lower,nuhat); CC1=reshape(tturntheta(1:16),[4,4]); CC2=reshape(tturntheta(17:32),[4,4]); CC1=CC1*CC1'; CC2=CC2*CC2'; if (find(eig(CC1)&lt;0.000000001)&gt;0) CC1=CC1+eps*eye(4); end if (find(eig(CC2)&lt;0.000000001)&gt;0) CC2=CC2+eps*eye(4); end theta&#123;1&#125;=[1,CC1(1,2)/sqrt(CC1(1,1)*CC1(2,2)),CC1(1,3)/sqrt(CC1(1,1)*CC1(3,3)),CC1(1,4)/sqrt(CC1(1,1)*CC1(4,4)); CC1(1,2)/sqrt(CC1(1,1)*CC1(2,2)),1,CC1(2,3)/sqrt(CC1(2,2)*CC1(3,3)),CC1(2,4)/sqrt(CC1(2,2)*CC1(4,4)); CC1(1,3)/sqrt(CC1(1,1)*CC1(3,3)),CC1(2,3)/sqrt(CC1(2,2)*CC1(3,3)),1,CC1(3,4)/sqrt(CC1(3,3)*CC1(4,4)); CC1(1,4)/sqrt(CC1(1,1)*CC1(4,4)),CC1(2,4)/sqrt(CC1(2,2)*CC1(4,4)),CC1(3,4)/sqrt(CC1(3,3)*CC1(4,4)),1]; theta&#123;2&#125;=[1,CC2(1,2)/sqrt(CC2(1,1)*CC2(2,2)),CC2(1,3)/sqrt(CC2(1,1)*CC2(3,3)),CC2(1,4)/sqrt(CC2(1,1)*CC2(4,4)); CC2(1,2)/sqrt(CC2(1,1)*CC2(2,2)),1,CC2(2,3)/sqrt(CC2(2,2)*CC2(3,3)),CC2(2,4)/sqrt(CC2(2,2)*CC2(4,4)); CC2(1,3)/sqrt(CC2(1,1)*CC2(3,3)),CC2(2,3)/sqrt(CC2(2,2)*CC2(3,3)),1,CC2(3,4)/sqrt(CC2(3,3)*CC2(4,4)); CC2(1,4)/sqrt(CC2(1,1)*CC2(4,4)),CC2(2,4)/sqrt(CC2(2,2)*CC2(4,4)),CC2(3,4)/sqrt(CC2(3,3)*CC2(4,4)),1]; theta&#123;3&#125;=tturntheta(33); theta&#123;4&#125;=tturntheta(34); theta&#123;5&#125;=tturntheta(35); theta; list1&#123;1,count+1&#125;=theta&#123;1&#125;; list1&#123;2,count+1&#125;=theta&#123;2&#125;; list1&#123;3,count+1&#125;=theta&#123;3&#125;; list1&#123;4,count+1&#125;=theta&#123;4&#125;; list1&#123;5,count+1&#125;=theta&#123;5&#125;; theta&#123;1&#125; theta&#123;2&#125; theta&#123;3&#125; theta&#123;4&#125; theta&#123;5&#125; list2(:,count+1)=omega; t=max([norm(tturntheta(:)-tturntheta_old(:));norm(omega_old(:)-omega(:))]) count=count+1endtoc 注：在多维模式下最应注意的是搜索过程中多维高斯Copula与t-Copula的相依结构参数应该保持正定 保持矩阵正定的方法假设 $A$ 矩阵正定，则;$A=Y\lambdaY^T$,其中 $\lambda$ 为对角线上为矩阵$A$的特征值的对角矩阵，$Y$为对应各特征值的特征向量矩阵。因此对于$B=Y\sqrt{\lambda}$，有$A=BB^T$。因此只需对$B$中的元素进行搜索就能保证最后合成的$A$一定为正定。 非线性优化部分12345678910111213141516171819202122232425262728293031323334353637383940414243444546function [turntheta,fval,exitflag,output]=update4theta(N,U,V,Z,M,ttheta,puz,t,n,lower,nuhat)ticoptions=optimset('Display','iter-detailed','MaxFunEvals',10000,'TolFun',1e-8,'TolX',1e-10,'LargeScale','on','HessUpdate','bfgs','UseParallel',1);[turntheta,fval,exitflag,output]=fmincon(@u4theta,ttheta,[],[],[],[],lower,[],[],options);function y=u4theta(ttheta) theta=cell(5,1); X1=reshape(ttheta(1:16),[4,4]); X2=reshape(ttheta(17:32),[4,4]); X1=X1*X1'; X2=X2*X2'; theta&#123;1&#125;=[1,X1(1,2)/sqrt(X1(1,1)*X1(2,2)),X1(1,3)/sqrt(X1(1,1)*X1(3,3)),X1(1,4)/sqrt(X1(1,1)*X1(4,4)); X1(1,2)/sqrt(X1(1,1)*X1(2,2)),1,X1(2,3)/sqrt(X1(2,2)*X1(3,3)),X1(2,4)/sqrt(X1(2,2)*X1(4,4)); X1(1,3)/sqrt(X1(1,1)*X1(3,3)),X1(2,3)/sqrt(X1(2,2)*X1(3,3)),1,X1(3,4)/sqrt(X1(3,3)*X1(4,4)); X1(1,4)/sqrt(X1(1,1)*X1(4,4)),X1(2,4)/sqrt(X1(2,2)*X1(4,4)),X1(3,4)/sqrt(X1(3,3)*X1(4,4)),1]; theta&#123;2&#125;=[1,X2(1,2)/sqrt(X2(1,1)*X2(2,2)),X2(1,3)/sqrt(X2(1,1)*X2(3,3)),X2(1,4)/sqrt(X2(1,1)*X2(4,4)); X2(1,2)/sqrt(X2(1,1)*X2(2,2)),1,X2(2,3)/sqrt(X2(2,2)*X2(3,3)),X2(2,4)/sqrt(X2(2,2)*X2(4,4)); X2(1,3)/sqrt(X2(1,1)*X2(3,3)),X2(2,3)/sqrt(X2(2,2)*X2(3,3)),1,X2(3,4)/sqrt(X2(3,3)*X2(4,4)); X2(1,4)/sqrt(X2(1,1)*X2(4,4)),X2(2,4)/sqrt(X2(2,2)*X2(4,4)),X2(3,4)/sqrt(X2(3,3)*X2(4,4)),1]; theta&#123;3&#125;=ttheta(33); theta&#123;4&#125;=ttheta(34); theta&#123;5&#125;=ttheta(35);if theta&#123;5&#125;==0 theta&#123;5&#125;=theta&#123;5&#125;+0.0001;endth1=theta&#123;1&#125;;th2=theta&#123;2&#125;;th3=theta&#123;3&#125;;th4=theta&#123;4&#125;;th5=theta&#123;5&#125;;y=0;Y=zeros(1,N);parfor j=1:N Y(j)=log(det(th1)^(-1/2)*exp(-1/2*n(j,:)*(th1^(1)-eye(4))*n(j,:)'))*puz(j,1)+... log(det(th2)^(-1/2)*gamma((nuhat+4)/2)*gamma(nuhat/2)^(3)*(1+t(j,:)*th2^(-1)*t(j,:)'/nuhat)^(-(nuhat+4)/2)/((gamma((nuhat+1)/2))^4*(1+t(j,1)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,2)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,3)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,4)^2/nuhat)^(-(nuhat+1)/2)))*puz(j,2)+... log((exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(4/th3 - 4))/(M(j)*U(j)*V(j)*Z(j)) + (th3^2*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(1/th3 - 1)^2*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(2/th3 - 4))/(M(j)*U(j)*V(j)*Z(j)) + (th3^2*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(2/th3 - 2)*(2/th3 - 3)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(2/th3 - 4))/(M(j)*U(j)*V(j)*Z(j)) - (2*th3*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(1/th3 - 1)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3 - 2)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(2/th3 - 2))/(M(j)*U(j)*V(j)*Z(j)) - (2*th3*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(2/th3 - 2)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3 - 1)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(2/th3 - 3))/(M(j)*U(j)*V(j)*Z(j)) - (th3^3*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(1/th3 - 1)*(1/th3 - 2)*(1/th3 - 3)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3 - 4))/(M(j)*U(j)*V(j)*Z(j)) + (2*th3^2*exp(-((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3))*(-log(M(j)))^(th3 - 1)*(-log(U(j)))^(th3 - 1)*(-log(V(j)))^(th3 - 1)*(-log(Z(j)))^(th3 - 1)*(1/th3 - 1)*(1/th3 - 2)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3 - 1)*((-log(M(j)))^th3 + (-log(U(j)))^th3 + (-log(V(j)))^th3 + (-log(Z(j)))^th3)^(1/th3 - 3))/(M(j)*U(j)*V(j)*Z(j)))*puz(j,3)+... log((th4^3*(1/th4 + 1)*(1/th4 + 2)*(1/th4 + 3))/(M(j)^(th4 + 1)*U(j)^(th4 + 1)*V(j)^(th4 + 1)*Z(j)^(th4 + 1)*(1/M(j)^th4 + 1/U(j)^th4 + 1/V(j)^th4 + 1/Z(j)^th4 - 3)^(1/th4 + 4)))*puz(j,4)+... log((7*th5^3*exp(2*log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*exp(-M(j)*th5)*exp(-U(j)*th5)*exp(-V(j)*th5)*exp(-Z(j)*th5)*(exp(-th5) - 1)^2)/((exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1) + 1)^2*(exp(-M(j)*th5) - 1)*(exp(-U(j)*th5) - 1)*(exp(-V(j)*th5) - 1)*(exp(-Z(j)*th5) - 1)) + (6*th5^3*exp(4*log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + 4*log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + 4*log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + 4*log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*exp(-M(j)*th5)*exp(-U(j)*th5)*exp(-V(j)*th5)*exp(-Z(j)*th5)*(exp(-th5) - 1)^4)/((exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1) + 1)^4*(exp(-M(j)*th5) - 1)*(exp(-U(j)*th5) - 1)*(exp(-V(j)*th5) - 1)*(exp(-Z(j)*th5) - 1)) - (th5^3*exp(-M(j)*th5)*exp(-U(j)*th5)*exp(-V(j)*th5)*exp(-Z(j)*th5)*exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1))/((exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1) + 1)*(exp(-M(j)*th5) - 1)*(exp(-U(j)*th5) - 1)*(exp(-V(j)*th5) - 1)*(exp(-Z(j)*th5) - 1)) - (12*th5^3*exp(2*log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + 2*log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*exp(-M(j)*th5)*exp(-U(j)*th5)*exp(-V(j)*th5)*exp(-Z(j)*th5)*exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1)^3)/((exp(log((exp(-M(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-U(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-V(j)*th5) - 1)/(exp(-th5) - 1)) + log((exp(-Z(j)*th5) - 1)/(exp(-th5) - 1)))*(exp(-th5) - 1) + 1)^3*(exp(-M(j)*th5) - 1)*(exp(-U(j)*th5) - 1)*(exp(-V(j)*th5) - 1)*(exp(-Z(j)*th5) - 1)))*puz(j,5);endy=-sum(Y);endtocend 参数估计结果1234567891011121314151617rho_n=[1.0000 -0.4594 0.6594 0.3254 -0.4594 1.0000 -0.8218 0.6426 0.6594 -0.8218 1.0000 -0.4552 0.3254 0.6426 -0.4552 1.0000];rho_t=[1.0000 0.6856 0.6195 0.6621 0.6856 1.0000 0.9344 0.3696 0.6195 0.9344 1.0000 0.3127 0.6621 0.3696 0.3127 1.0000];rho_g=1.9479;rho_c=0.0010;rho_f=2.0234;omega=[0 0.7098 0.1432 0.0364 0.1106] 欧式距离 $d_m=6.6293$ 可以看出从欧氏距离上讲，确实混合Copula模型比单个Copula建模的效果要好。由于高斯Copula在多维下并不能表现出尾部相关性，因此其权重参数为0。其余的Copula基本是按照各自拟合优度占据权重。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多维形式的Copula函数推导及建模]]></title>
      <url>%2F2017%2F04%2F06%2F%E5%A4%9A%E7%BB%B4%E5%BD%A2%E5%BC%8F%E7%9A%84Copula%E5%87%BD%E6%95%B0%E6%8E%A8%E5%AF%BC%E5%8F%8A%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[两种CopulaCopula函数主要分为两种，一种为椭圆族Copula，一种为Archimedean-Copula。其中椭圆族Copula直接给出了其多维形式，具体详见《MATLAB统计分析与应用：40个案例分析》P189。而Archimedean-Copula的函数由于各种生成元的不同导致只给出了常用的二元形式。多维形式需要手动推导。 对多维Archimedean-Copula推导对于分布函数的推导根据书中P190给出的生成元与基础形式，推导出各自生成元的反函数，然后将生成元带入，得到四维Copula分布函数。12345678Gumbelcdf =exp(-((-log(U)).^a+(-log(V)).^a+(-log(Z)).^a+(-log(M)).^a).^(1./a))Claytoncdf =(U.^(-a)+V.^(-a)+Z.^(-a)+M.^(-a)-3).^(-1./a)Frankcdf =-log(exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1)./a 对于密度函数的推导根据定义，密度函数是对分布函数中的多个样本进行多次求偏导得到的。由于函数较为复杂，手动推导会带来很大的麻烦，因而采用MATLAB程序进行推导。 1234567891011121314151617181920212223clear all;syms U V Z M a dS1='exp(-((-log(U))^a+(-log(V))^a+(-log(Z))^a+(-log(M))^a)^(1/a))';d=S1;v=[U V Z M];for i=1:4 d=diff(d,v(i));endGum=dS2='(U^(-a)+V^(-a)+Z^(-a)+M^(-a)-3)^(-1/a)'d=S2;v=[U V Z M];for i=1:4 d=diff(d,v(i));endClay=dS3='-log(exp(log((exp(-M*a) - 1)/(exp(-a) - 1)) + log((exp(-U*a) - 1)/(exp(-a) - 1)) + log((exp(-V*a) - 1)/(exp(-a) - 1)) + log((exp(-Z*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1) + 1)/a';d=S3;v=[U V Z M];for i=1:4 d=diff(d,v(i));endFrank=d 求得结果 12345678Gum =(exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(4./a - 4))./(M.*U.*V.*Z) + (a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).^2.*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 4))./(M.*U.*V.*Z) + (a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(2./a - 2).*(2./a - 3).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 4))./(M.*U.*V.*Z) - (2.*a.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 2))./(M.*U.*V.*Z) - (2.*a.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(2./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 3))./(M.*U.*V.*Z) - (a.^3.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*(1./a - 2).*(1./a - 3).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 4))./(M.*U.*V.*Z) + (2.*a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*(1./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 3))./(M.*U.*V.*Z)Clay =(a.^3.*(1./a + 1).*(1./a + 2).*(1./a + 3))./(M.^(a + 1).*U.^(a + 1).*V.^(a + 1).*Z.^(a + 1).*(1./M.^a + 1./U.^a + 1./V.^a + 1./Z.^a - 3).^(1./a + 4))Frank =(7.*a.^3.*exp(2.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*(exp(-a) - 1).^2)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^2.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) + (6.*a.^3.*exp(4.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*(exp(-a) - 1).^4)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^4.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) - (a.^3.*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1))./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) - (12.*a.^3.*exp(2.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1).^3)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^3.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) 注：以上是经过修正后能直接进行矩阵计算的结果，修正方法为将原结果中的`,^,/转换为.,.^,./` 多维Copula参数估计MATLAB自带的函数不支持多维的Archimdean-Copula的参数估计与函数计算，因此需要自己写出极大似然估计算法。由于MATLAB自带的极大似然估计函数mle不支持多维变量的输入，因此先计算出对数似然函数，然后利用非线性优化函数fmincon求解对应的参数值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function para=copula4fit(name,data)options = optimset('Algorithm','interior-point','MaxFunEvals',1000,'Display','iter-detailed','TolCon',10^-12,'TolFun',10^-4,'TolX',10^-6);switch name case 'Gumbel' lower = 1.1; a = 2; [ para LL6] = fmincon(@mlepdffun_G,a,[],[],[],[],lower,[],[],options); case 'Clayton' lower = 0.0001; a = 1; [ para LL2] = fmincon(@mlepdffun_C,a,[],[],[],[],lower,[],[],options); case 'Frank' theta0 = 1; [ para LL5] = fmincon(@mlepdffun_F,theta0,[],[],[],[],[],[],[],options);end function y=mlepdffun_G(a) U=data(:,1); V=data(:,2); Z=data(:,3); M=data(:,4); N=numel(U); Y=zeros(size(U)); parfor i=1:N Y(i)=log((exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(4/a - 4))/(M(i)*U(i)*V(i)*Z(i)) + (a^2*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(1/a - 1)^2*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(2/a - 4))/(M(i)*U(i)*V(i)*Z(i)) + (a^2*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(2/a - 2)*(2/a - 3)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(2/a - 4))/(M(i)*U(i)*V(i)*Z(i)) - (2*a*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(1/a - 1)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a - 2)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(2/a - 2))/(M(i)*U(i)*V(i)*Z(i)) - (2*a*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(2/a - 2)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a - 1)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(2/a - 3))/(M(i)*U(i)*V(i)*Z(i)) - (a^3*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(1/a - 1)*(1/a - 2)*(1/a - 3)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a - 4))/(M(i)*U(i)*V(i)*Z(i)) + (2*a^2*exp(-((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a))*(-log(M(i)))^(a - 1)*(-log(U(i)))^(a - 1)*(-log(V(i)))^(a - 1)*(-log(Z(i)))^(a - 1)*(1/a - 1)*(1/a - 2)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a - 1)*((-log(M(i)))^a + (-log(U(i)))^a + (-log(V(i)))^a + (-log(Z(i)))^a)^(1/a - 3))/(M(i)*U(i)*V(i)*Z(i))); end y=-sum(Y); end function y=mlepdffun_C(a) U=data(:,1); V=data(:,2); Z=data(:,3); M=data(:,4); N=numel(U); Y=zeros(size(U)); parfor i=1:N Y(i)=log((a^3*(1/a + 1)*(1/a + 2)*(1/a + 3))/(M(i)^(a + 1)*U(i)^(a + 1)*V(i)^(a + 1)*Z(i)^(a + 1)*(1/M(i)^a + 1/U(i)^a + 1/V(i)^a + 1/Z(i)^a - 3)^(1/a + 4))); end y=-sum(Y); end function y=mlepdffun_F(a) U=data(:,1); V=data(:,2); Z=data(:,3); M=data(:,4); N=numel(U); Y=zeros(size(U)); parfor i=1:N Y(i)=log((7*a^3*exp(2*log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*exp(-M(i)*a)*exp(-U(i)*a)*exp(-V(i)*a)*exp(-Z(i)*a)*(exp(-a) - 1)^2)/((exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1) + 1)^2*(exp(-M(i)*a) - 1)*(exp(-U(i)*a) - 1)*(exp(-V(i)*a) - 1)*(exp(-Z(i)*a) - 1)) + (6*a^3*exp(4*log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + 4*log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + 4*log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + 4*log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*exp(-M(i)*a)*exp(-U(i)*a)*exp(-V(i)*a)*exp(-Z(i)*a)*(exp(-a) - 1)^4)/((exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1) + 1)^4*(exp(-M(i)*a) - 1)*(exp(-U(i)*a) - 1)*(exp(-V(i)*a) - 1)*(exp(-Z(i)*a) - 1)) - (a^3*exp(-M(i)*a)*exp(-U(i)*a)*exp(-V(i)*a)*exp(-Z(i)*a)*exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1))/((exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1) + 1)*(exp(-M(i)*a) - 1)*(exp(-U(i)*a) - 1)*(exp(-V(i)*a) - 1)*(exp(-Z(i)*a) - 1)) - (12*a^3*exp(2*log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + 2*log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*exp(-M(i)*a)*exp(-U(i)*a)*exp(-V(i)*a)*exp(-Z(i)*a)*exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1)^3)/((exp(log((exp(-M(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-U(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-V(i)*a) - 1)/(exp(-a) - 1)) + log((exp(-Z(i)*a) - 1)/(exp(-a) - 1)))*(exp(-a) - 1) + 1)^3*(exp(-M(i)*a) - 1)*(exp(-U(i)*a) - 1)*(exp(-V(i)*a) - 1)*(exp(-Z(i)*a) - 1))); end y=-sum(Y); endend 多维Copula函数值计算多维分布函数12345678910111213function c=copula4cdf(name,data,a)U=data(:,1);V=data(:,2);Z=data(:,3);M=data(:,4);switch name case 'Gumbel' c=exp(-((-log(U)).^a+(-log(V)).^a+(-log(Z)).^a+(-log(M)).^a).^(1./a)); case 'Clayton' c=(U.^(-a)+V.^(-a)+Z.^(-a)+M.^(-a)-3).^(-1./a); case 'Frank' c=-log(exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1)./a;end 多维密度函数12345678910111213function p=copula4pdf(name,data,a)U=data(:,1);V=data(:,2);Z=data(:,3);M=data(:,4);switch name case 'Gumbel' p=(exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(4./a - 4))./(M.*U.*V.*Z) + (a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).^2.*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 4))./(M.*U.*V.*Z) + (a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(2./a - 2).*(2./a - 3).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 4))./(M.*U.*V.*Z) - (2.*a.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 2))./(M.*U.*V.*Z) - (2.*a.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(2./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(2./a - 3))./(M.*U.*V.*Z) - (a.^3.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*(1./a - 2).*(1./a - 3).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 4))./(M.*U.*V.*Z) + (2.*a.^2.*exp(-((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a)).*(-log(M)).^(a - 1).*(-log(U)).^(a - 1).*(-log(V)).^(a - 1).*(-log(Z)).^(a - 1).*(1./a - 1).*(1./a - 2).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 1).*((-log(M)).^a + (-log(U)).^a + (-log(V)).^a + (-log(Z)).^a).^(1./a - 3))./(M.*U.*V.*Z); case 'Clayton' p=(a.^3.*(1./a + 1).*(1./a + 2).*(1./a + 3))./(M.^(a + 1).*U.^(a + 1).*V.^(a + 1).*Z.^(a + 1).*(1./M.^a + 1./U.^a + 1./V.^a + 1./Z.^a - 3).^(1./a + 4)); case 'Frank' p=(7.*a.^3.*exp(2.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*(exp(-a) - 1).^2)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^2.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) + (6.*a.^3.*exp(4.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 4.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*(exp(-a) - 1).^4)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^4.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) - (a.^3.*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1))./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1)) - (12.*a.^3.*exp(2.*log((exp(-M.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-U.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-V.*a) - 1)./(exp(-a) - 1)) + 2.*log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*exp(-M.*a).*exp(-U.*a).*exp(-V.*a).*exp(-Z.*a).*exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1).^3)./((exp(log((exp(-M.*a) - 1)./(exp(-a) - 1)) + log((exp(-U.*a) - 1)./(exp(-a) - 1)) + log((exp(-V.*a) - 1)./(exp(-a) - 1)) + log((exp(-Z.*a) - 1)./(exp(-a) - 1))).*(exp(-a) - 1) + 1).^3.*(exp(-M.*a) - 1).*(exp(-U.*a) - 1).*(exp(-V.*a) - 1).*(exp(-Z.*a) - 1));end 多维单一Copula建模1234567891011121314151617181920212223242526272829rho_n=copulafit('Gaussian',[QWC,BDQC,GHKC,CMC]);[rho_t,df]=copulafit('t',[QWC,BDQC,GHKC,CMC]);rho_g=copula4fit('Gumbel',[QWC,BDQC,GHKC,CMC]);rho_c=copula4fit('Clayton',[QWC,BDQC,GHKC,CMC]);rho_f=copula4fit('Frank',[QWC,BDQC,GHKC,CMC]);[fx,xsort]=ecdf(qw);[fy,ysort]=ecdf(bdq);[fz,zsort]=ecdf(ghk);[fn,nsort]=ecdf(cm);U1=spline(xsort(2:end),fx(2:end),qw);U2=spline(ysort(2:end),fy(2:end),bdq);U3=spline(zsort(2:end),fz(2:end),ghk);U4=spline(nsort(2:end),fn(2:end),cm);C=@(u1,u2,u3,u4)mean((U1&lt;=u1).*(U2&lt;=u2).*(U3&lt;=u3).*(U4&lt;=u4));CU=zeros(size(U1(:)));for i=1:numel(U1) CU(i)=C(U1(i),U2(i),U3(i),U4(i));endC_n=copulacdf('Gaussian',[QWC,BDQC,GHKC,CMC],rho_n);C_t=copulacdf('t',[QWC,BDQC,GHKC,CMC],rho_t,df);C_g=copula4cdf('Gumbel',[QWC,BDQC,GHKC,CMC],rho_g);C_c=copula4cdf('Clayton',[QWC,BDQC,GHKC,CMC],rho_c);C_f=copula4cdf('Frank',[QWC,BDQC,GHKC,CMC],rho_f);d_n=(CU-C_n)'*(CU-C_n);d_t=(CU-C_t)'*(CU-C_t);d_g=(CU-C_g)'*(CU-C_g);d_c=(CU-C_c)'*(CU-C_c);d_f=(CU-C_f)'*(CU-C_f); 结果及评价12345678910111213141516171819202122232425rho_n = 1.0000 0.6339 0.5346 0.6108 0.6339 1.0000 0.8092 0.3639 0.5346 0.8092 1.0000 0.3028 0.6108 0.3639 0.3028 1.0000rho_t = 1.0000 0.6441 0.5591 0.6179 0.6441 1.0000 0.8427 0.3769 0.5591 0.8427 1.0000 0.3204 0.6179 0.3769 0.3204 1.0000rho_g = 1.5298rho_c = 0.4995rho_f = 3.5044 评价欧式距离 1234567891011121314151617181920212223d_n = 11.0717d_t = 7.0748d_g = 48.8770d_c = 258.5072d_f = 48.3227 欧氏距离 $d_n$ $d_t$ $d_G$ $d_C$ $d_F$ 计算值 11.0717 7.0748 48.8770 258.5072 48.3227 我认为在对于多维变量的处理上，由于Archimedean-Copula函数仅仅通过一个变量来描述其多位相关性并不是很合理，因而通过一个结构相依矩阵来表述相关性的t-Copula与Normal-Copula就与源数据拟合方面表现的就更好]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阶段性总结]]></title>
      <url>%2F2017%2F03%2F29%2F%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[风速的随机性数学表述通过查阅文献可以得知，可以使用双参数威布尔分布来描述风速的概率分布 双参数威布尔函数$$F_w(x)=1-exp(-({x \over c})^k)$$其概率密度函数为$$P(x)={k \over c} ({k \over c})^{k-1}exp(-({x \over c})^k)$$式中 $k$ 为形状参数，无量纲； $c$ 为尺度参数，反映风电场的平均风速，单位为 $m/s$ 。 程序验证随机性通过将风速数据的频数分布图与根据风速数据拟合的威布尔分布概率密度函数曲线进行对比可以发现，使用双参数威布尔分布去拟合风速数据是完全合理的。下图中红色的曲线为威布尔分布概率密度函数曲线，蓝色部分为风速的频率分布直方图。 场间风速的关系通过对拟合后的风速数据的分布函数绘制频数分布直方图可以简单的看出场间风速的一些关系。下图为桥湾（1）、北大桥（2）、干河口（3）以及昌马（4）四个风电场两两之间的风速频数分布直方图 对于以上的关系可以通过地理以及气象等知识进行解释。下图是四个风电场的地理位置关系。 桥湾（1）与北大桥（2）间地理位置是东西平行，在东西风向盛行的酒泉地区两者风况有较大的相似，所以线性相关性较大，如图2-1 干河口（3）与桥湾（1）的地理位置虽然接近东西平行，但是距离较远，因此线性相关性较低，如图2-2 桥湾（1）与昌马（4）间地理位置接近南北垂直，但是由于两者间距离较近，所以线性相关性也较为明显，如图2-3 干河口（3）与北大桥（2）的地理位置接近东西平行的，在东西风向盛行的酒泉地区两者风况有较大的相似。如图2-4可以看出存在较大的线性相关性。 昌马（4）与北大桥（2）的距离较远，因此线性相关性较差，如图2-5 干河口（3）与昌马（4）的距离最远，因此线性相关性也最差，如图2-6 对场间风速进行建模 通过单个copula函数对场间风速进行建模参数估计结果 风电场组合 $\rho_{Norm}$ $\rho_t$ $k$ $\theta_G$ $\theta_C$ $\theta_F$ 桥湾与北大桥 0.6339 0.6386 9.1619 1.8533 0.6913 5.0402 桥湾与干河口 0.5346 0.5364 9.7829 1.6350 0.4847 3.8853 桥湾与昌马 0.6108 0.6169 10.4474 1.7697 0.6530 4.8459 北大桥与干河口 0.8092 0.8479 2.7192 2.9270 1.4685 9.8959 北大桥与昌马 0.3639 0.3630 33.9054 1.3098 0.3072 2.3697 干河口与昌马 0.3028 0.3026 21.9903 1.2628 0.2141 1.9736 对建模结果进行评价 与根据风速数据建立的经验Copula函数进行对比 使用Q-Q图进行校验（非定量分析） 通过Q-Q图的判定原则可知，各类Copula函数差别很明显，其 中Gumbel-Copula，Frank-Copula，t-Copula函数曲线均较为接近45°曲线，拟合效果相对较好。以下采用统计法 使用K-S校验进行定量分析 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ 桥湾，北大桥 0.0406 0.0395 0.0302 0.0520 0.0364 桥湾，干河口 0.0260 0.0219 0.0156 0.0489 0.0208 桥湾，昌马 0.0260 0.0239 0.0156 0.0499 0.0239 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 北大桥，昌马 0.0239 0.0239 0.0156 0.0385 0.0166 干河口，昌马 0.0208 0.0208 0.0146 0.0385 0.0156 通过K-S检验法的判定原则可知，在六种不同的风电场组合中，Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数的 $KS$ 统计值相对较小，而Normal-Copula，Clayton-Copula的统计值相对较大 秩相关性测度 数据来源 Kendall秩相关系数 $\tau$ Spearman秩相关系数 $\rho_s$ 原始观测数据 0.4816 0.6628 Normal-Copula 0.4371 0.6159 t-Copula 0.4410 0.6151 Gumbel-Copula 0.4604 0.6366 Clayton-Copula 0.2569 0.3751 Frank-Copula 0.4592 0.6465 通过与经验函数的Kendall秩相关系数，Spearman秩相关系数进行对比可以发现Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与原始数据保持着良好的秩相关性，而Normal-Copula，Clayton-Copula的秩相关性较差。 使用欧式距离进行分析 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ 桥湾，北大桥 2.8924 2.8209 1.3953 9.1763 2.4125 桥湾，干河口 2.7285 2.6970 1.1862 8.2528 2.2180 桥湾，昌马 2.3450 2.2558 1.3469 8.3662 1.8227 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 北大桥，昌马 1.7187 1.7470 1.5995 5.0238 1.3692 干河口，昌马 1.8369 1.8561 1.3731 4.8842 1.4301 可以看到在以上6种风电场组合中Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与经验Copula函数的欧氏距离较小，而Normal-Copula，Clayton-Copula与经验函数的欧氏距离较大 使用多个Copula函数进行混合对风速进行建模通过查阅文献可以知道，多个Copula函数通过加权相加后仍然是Copula函数 由于Copula函数并非线性函数，简单的通过单个Copula函数拟合效果来选择使用哪几个Copula函数来进行混合可能不够准确，可能会存在两个单一表现并不好的Copula函数混合后结果却比较好的情况。 因此，将论文中的三个Copula混合模型拓展至五个常用Copula进行混合建模。 由于混合时运算量过大，因此选取干河口与北大桥的场间风速为例进行建模 三个Copula混合的参数结果 Copula函数 $\theta$ $\omega$ $k$ t-Copula 0.1244 0.0822 3 Gumbel-Copula 4.1127 0.7495 Frank-Copula 6.5931 0.1683 即$$C(u,v;a)=0.7495C{Gumbel}(u,v;4.1127)+0.1683C{Frank}(u,v;6.5931)+0.0822C_t(u,v;0.1244,3)$$ 五个Copula混合的参数结果 Copula函数 $\theta$ $\omega$ $k$ t-Copula 0.9678 0.1075 2.7192 Gumbel-Copula 3.7781 0.5502 Frank-Copula 9.8959 0.1946 Norm-Copula 0.9250 0.0613 Clayton-Copula 0.0049 0.0864 即$$\begin{aligned}C(u,v;a)= &amp; 0.1075C_t(u,v;0.9678,2.7192)+0.0613CN(u,v;0.9250)+\&amp; 0.5502C{Gumbel}(u,v;3.7781)+0.1946C{Frank}(u,v;9.8959)+0.0864C{Clayton}(u,v;0.0049)\end{aligned} $$ 模型评价 Q-Q图校验 由于不是定量分析，对比效果不明显，以下采用定量分析，但是可以对比单个Copula时的QQ图 可以明显看出混合Copula的效果比单个Copula效果要好。 K-S检验 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ $K_{3M}$ $K_{5M}$ 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 0.0271 0.0260 可以看出5个Copula混合时的模型较3个Copula混合时的效果更好 欧氏距离 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ $d_{3M}$ $d_{5M}$ 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 1.3220 1.2730 从欧氏距离上也能够得到与KS检验中同样的结果 使用多元Copula进行4维风电场间风速建模使用单一多维Copula建模 分别得到了Normal-Copula与t-Copula的多元风速相依结构矩阵 $$\rho_n=\begin{bmatrix}1 &amp; 0.6339 &amp; 0.5346 &amp; 0.6108\0.6339 &amp; 1 &amp; 0.8092 &amp; 0.3639\0.5346 &amp; 0.8092 &amp; 1 &amp; 0.3028\0.6108 &amp; 0.3639 &amp; 0.3028 &amp; 1\end{bmatrix}$$ $$\rho_t=\begin{bmatrix}1 &amp;0.6441 &amp;0.5591 &amp;0.6179 \0.6441 &amp;1 &amp;0.8527 &amp;0.3769 \0.5591 &amp;0.8527 &amp;1 &amp;0.3204 \0.6179 &amp;0.3769 &amp;0.3204 &amp;1\end{bmatrix}$$ $$k_t=7.8639$$ 模型评价 K-S校验 $$k_G=0.0281\k_t=0.0401$$ 欧氏距离 $$d_G=11.0717\d_t=7.0748$$ 后来通过查阅文献得知KS校验不能在多维问题中使用，多维问题主要使用欧氏距离进行分析 使用多维混合Copula两种思路 使用多维的Copula直接进行混合问题： Archimedean Copula族的Copula函数需要手动计算多维形式，并手动编程通过MLE方法估算函数参数，MATLAB自带的fit函数仅支持二元的Archimedean Copula参数估计。并且在计算4维t-Copula概率密度函数时的计算量非常大，单句指令需要运算三个小时，当嵌套至EM算法的迭代中时将耗费更多的时间，预计计算时间将达到十几天。 通过pair-Copula将多个二维Copula函数进行合并，直至出现四维Copula问题：暂时没有找到对于pair-Copula构建过程较为详细的文献，还处在摸索阶段 光伏的随机性表达通过核密度估计来表达长时间内的光伏照射强度定义 : 设$x_1,x_2,…,x_n$为随机变量$x$的样本，令随机变量$x$的概率密度函数为$f(x)$，则 $f(x)$ 的核密度估计为： $$fh(x)={1 \over nh}{\displaystyle \sum{j=1}^n{K({x-xj \over h})}}={1 \over n}{\displaystyle \sum{j=1}^n{K_h(x-x_j)}}$$ 其中$n$为样本容量，$h$ 为平滑系数，$K(·)$ 为核函数 结果 可以看到在长时间尺度上（上例为半年）核密度估计的拟合程度很高，但是在稍短的时间尺度上（一个月）则效果较差，如下图 该种情况可以通过调整窗的宽度来提高拟合优度，如下图为窗宽度为2.5时重新拟合一个月的光伏强度结果 附录所有代码详见Copula_Wind]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[混合Copula建模修正——更多Copula函数的加入]]></title>
      <url>%2F2017%2F03%2F23%2F%E6%B7%B7%E5%90%88Copula%E5%BB%BA%E6%A8%A1%E4%BF%AE%E6%AD%A3%2F</url>
      <content type="text"><![CDATA[修正的原因由于Copula函数并非线性函数，简单的通过单个Copula函数拟合效果来选择使用哪几个Copula函数来进行混合可能不够准确，可能会存在两个单一表现并不好的Copula函数混合后结果却比较好的情况。 因此，将原来的混合Copula模型拓展至五个常用Copula进行混合建模。 修正后的代码EM算法主体部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374U=GHKC;V=BDQC;% 初始化S=5;th=0.01;omega=[1/5,1/5,1/5,1/5,1/5];[a,nuhat]=copulafit('t',[U,V]);a2=copulafit('Gumbel',[U,V]);a3=copulafit('Frank',[U,V]);a4=copulafit('Gaussian',[U,V]);a5=copulafit('Clayton',[U,V]);theta=[a(1,2),a2,a3,a4(1,2),a5];[N,~]=size(U);count=0;tt=zeros(N,2);nn=zeros(N,2);tt(:,1)=tinv(U(:),nuhat);tt(:,2)=tinv(V(:),nuhat);nn(:,1)=norminv(U(:));nn(:,2)=norminv(V(:));t=inf;COPULA=zeros(N,S);list1=zeros(5,101);list2=zeros(5,101);puz=zeros(N,S);puz1=zeros(N,S);turntheta_old=zeros(1,S);ticwhile t&gt;=th&amp;&amp;count&lt;=50; theta_old=theta; omega_old=omega; %转化为无约束限制的参数 turntheta_old(1)=tan(pi*theta_old(1)/2); turntheta_old(2)=log(theta_old(2)-1); turntheta_old(4)=tan(pi*theta_old(4)/2); turntheta_old(5)=log(theta_old(5)); COPULA(:,1)=copulapdf('t',[U(:) V(:)],theta_old(1),nuhat); COPULA(:,2)=copulapdf('Gumbel',[U(:) V(:)],theta_old(2)); COPULA(:,3)=copulapdf('Frank',[U(:) V(:)],theta_old(3)); COPULA(:,4)=copulapdf('Gaussian',[U(:) V(:)],theta_old(4)); COPULA(:,5)=copulapdf('Clayton',[U(:) V(:)],theta_old(5)); puz(:,1)=COPULA(:,1)*omega_old(1); puz(:,2)=COPULA(:,2)*omega_old(2); puz(:,3)=COPULA(:,3)*omega_old(3); puz(:,4)=COPULA(:,4)*omega_old(4); puz(:,5)=COPULA(:,5)*omega_old(5); for i=1:N puz1(i,1)=puz(i,1)/sum(puz(i,:)); puz1(i,2)=puz(i,2)/sum(puz(i,:)); puz1(i,3)=puz(i,3)/sum(puz(i,:)); puz1(i,4)=puz(i,4)/sum(puz(i,:)); puz1(i,5)=puz(i,5)/sum(puz(i,:)); end omega(1)=sum(puz1(:,1))/N; omega(2)=sum(puz1(:,2))/N; omega(3)=sum(puz1(:,3))/N; omega(4)=sum(puz1(:,4))/N; omega(5)=sum(puz1(:,5))/N; omega tic [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,turntheta_old,puz1,tt,nn,nuhat); toc theta(1)=atan(turntheta(1))*2/pi; theta(2)=exp(turntheta(2))+1; theta(4)=atan(turntheta(4))*2/pi; theta(5)=exp(turntheta(5)); theta list1(:,count+1)=theta; list2(:,count+1)=omega; t=max([norm(theta_old(:)-theta(:));norm(omega_old(:)-omega(:))]) count=count+1endtocbeep 代码中涉及对参数进行数学变换将其参数从各自有限定义域转为$(-\infty,+ \infty)$ 其中: t-Copula与正态Copula参数定义域为$(-1,1)$ Gumbel-Copula参数定义域为$(1,+\infty)$ Clayton-Copula参数定义域为$(0,+\infty)$ Frank-Copula参数定义域为$(-\infty,+\infty)$ 参数更新部分123456789101112131415161718192021222324252627function [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,theta,puz,t,n,nuhat)options=optimset('Display','iter-detailed','MaxFunEvals',1000,'TolFun',1e-6,'TolX',1e-10,'LargeScale','on','FinDiffType','central','HessUpdate','bfgs');[turntheta,fval,exitflag,output,grad,hessian]=fminunc(@utheta,theta,options);function y=utheta(theta)if theta(3)==0 theta(3)=theta(3)+0.0001; %防止出现 Frank Copula 的相依结构参数为 0endy=0;th=eye(2);th1=eye(2);th(1,2)=atan(theta(1))*2/pi;th(2,1)=atan(theta(1))*2/pi;th1(1,2)=atan(theta(4))*2/pi;th1(2,1)=atan(theta(4))*2/pi;for j=1:N y=y+log(((det(th))^(-1/2))*gamma((nuhat+2)/2)*gamma(nuhat/2)*(1+t(j,:)*th^(-1)*t(j,:)'/nuhat)^(-(nuhat+2)/2)/((gamma((nuhat+1)/2))^2*((1+t(j,1)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,2)^2/nuhat)^(-(nuhat+1)/2))))*puz(j,1)+... log(exp(-((-log(U(j)))^(exp(theta(2))+1)+(-log(V(j)))^(exp(theta(2))+1))^(1/(exp(theta(2))+1)))*(log(U(j))*log(V(j)))^((exp(theta(2))+1)-1)*(((-log(U(j)))^((exp(theta(2))+1))+(-log(V(j)))^((exp(theta(2))+1)))^(1/(exp(theta(2))+1))+(exp(theta(2))+1)-1)/(U(j)*V(j)*((-log(U(j)))^((exp(theta(2))+1))+(-log(V(j)))^((exp(theta(2))+1)))^(2-1/(exp(theta(2))+1))))*puz(j,2)+... log(theta(3)*(1-exp(-theta(3)))*exp(-theta(3)*(U(j)+V(j)))/((1-exp(-theta(3)))-(1-exp(-theta(3)*U(j)))*(1-exp(-theta(3)*V(j))))^2)*puz(j,3)+... log((det(th1))^(-1/2)*exp(-1/2*n(j,:)*(th1^(-1)-eye(2))*n(j,:)'))*puz(j,4)+... log((1+exp(theta(5)))*(U(j)*V(j))^(-exp(theta(5))-1)*(U(j)^(-exp(theta(5)))+V(j)^(-exp(theta(5)))-1)^(-2-1/exp(theta(5))))*puz(j,5);endy=-y;endend 结果分析参数 Copula函数 $\theta$ $\omega$ $k$ t-Copula 0.9678 0.1075 2.7192 Gumbel-Copula 3.7781 0.5502 Frank-Copula 9.8959 0.1946 Norm-Copula 0.9250 0.0613 Clayton-Copula 0.0049 0.0864 Q-Q图与3个Copula函数混合时的模型相比： 由于不是定量分析，对比效果不明显，以下采用定量分析 KS检验 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ $K_{3M}$ $K_{5M}$ 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 0.0271 0.0260 可以看出5个Copula混合时的模型较3个Copula混合时的效果更好 欧式距离 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ $d_{3M}$ $d_{5M}$ 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 1.3220 1.2730 从欧氏距离上也能够得到与KS检验中同样的结果 结论综上，可以将混合Copula模型更新为如下形式 $$\begin{aligned}C(u,v;a)= &amp; 0.1075C_t(u,v;0.9678,2.7192)+0.0613CN(u,v;0.9250)+\&amp; 0.5502C{Gumbel}(u,v;3.7781)+0.1946C{Frank}(u,v;9.8959)+0.0864C{Clayton}(u,v;0.0049)\end{aligned} $$ PS:以上程序跑了9个小时，由于本人电脑运算处理速度问题，暂且限制在该精度下，但是结果仍可更加精确，后面会使用工作站进行进一步的精确计算]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[光伏建模（2）——核密度估计实现]]></title>
      <url>%2F2017%2F03%2F17%2F%E5%85%89%E4%BC%8F%E5%BB%BA%E6%A8%A1%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[数据录入12345678910111213141516171819202122232425262728solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\一月\太阳能测光数据_2010-01-01 - 2010-02-01.xls');solardata=solar(:,2);SData=cell(1,7);SData(1)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\二月\太阳能测光数据_2010-02.xls');solardata=[solardata; solar(:,2)]SData(2)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\三月\太阳能测光数据_2010-03-01 - 2010-04-01.xls');solardata=[solardata; solar(:,2)]SData(3)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\四月\太阳能测光数据_2010-04-01 - 2010-05-01.xls');solardata=[solardata; solar(:,2)]SData(4)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\五月\太阳能测光数据_2010-05-01 - 2010-06-01.xls');solardata=[solardata; solar(:,2)]SData(5)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\六月\太阳能测光数据_2010-06-01 - 2010-07-01.xls');solardata=[solardata; solar(:,2)]SData(6)=&#123;solar&#125;;solar=xlsread('E:\学习\毕设\数据资料\数据资料\windfarm data\敦煌太阳能测光数据1-7\七月\太阳能测光数据2010-7-1-2010-8-1.xls');solardata=[solardata; solar(:,3)]SData(7)=&#123;solar&#125;; 使用核密度估计对长时间内的光伏强度进行估计代码实现123456[fsd,sdc]=ecdf(solardata);[fks,ksc]=ksdensity(solardata,[-100:1:1200]);figure;ecdfhist(fsd,sdc,100);hold onplot(ksc,fks,'-r') 在默认情况下核函数选取的是高斯核函数，事实上在所有核函数中，高斯与epanechnikov这两种核函数拟合效果较好 结果 可以看到在长时间尺度上（上例为半年）核密度估计的拟合程度很高，但是在稍短的时间尺度上（一个月）则效果较差，如下图 该种情况可以通过调整窗的宽度来提高拟合优度，如下图为窗宽度为2.5时重新拟合一个月的光伏强度结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[光伏建模——核密度估计而非Beta分布]]></title>
      <url>%2F2017%2F03%2F15%2F%E5%85%89%E4%BC%8F%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[光伏建模与风速建模的不同 对与风速建模而言，其符合双参数威布尔分布表示其样本数据符合双参数威布尔数据样本的特征 对于光伏建模而言，所谓的使用beta分布拟合光伏实际意义为在短时间内（一天之内）光照强度的曲线可以通过beta分布的概率密度函数去近似拟合 此二者有本质区别，因此如果仅通过曲线拟合表示光伏建模数据不能称作光伏建模随机性的数学表述，因此在缺乏先验的情况下只能求助于仅基于样本数据核密度估计 非参数核密度估计定义 : 设$x_1,x_2,…,x_n$为随机变量$x$的样本，令随机变量$x$的概率密度函数为$f(x)$，则 $f(x)$ 的核密度估计为： $$fh(x)={1 \over nh}{\displaystyle \sum{j=1}^n{K({x-xj \over h})}}={1 \over n}{\displaystyle \sum{j=1}^n{K_h(x-x_j)}}$$ 其中$n$为样本容量，$h$ 为平滑系数，$K(·)$ 为核函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[混合Copula风速建模——代码实现与结果分析]]></title>
      <url>%2F2017%2F03%2F10%2F%E6%B7%B7%E5%90%88Copula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E2%80%94%E2%80%94%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[由于仿真一次所耗时间较长，因此选择北大桥与干河口风电场作为代表 EM算法估计混合Copula参数EM主体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647U=GHK;V=BDQ;% 初始化S=3;th=0.01;omega=[1/3,1/3,1/3];[a,nuhat]=copulafit('t',[U,V]);a2=copulafit('Gumbel',[U,V]);a3=copulafit('Frank',[U,V]);theta=[a(1,2),a2,a3];[N,~]=size(U);count=0;tt=zeros(N,2);t=inf;COPULA=zeros(N,S);list1=zeros(3,101);list2=zeros(3,101);puz=zeros(N,S);puz1=zeros(N,S);while t&gt;=th&amp;&amp;count&lt;=100; theta_old=theta; omega_old=omega; COPULA(:,1)=copulapdf('t',[U(:) V(:)],theta_old(1),nuhat); COPULA(:,2)=copulapdf('Gumbel',[U(:) V(:)],theta_old(2)); COPULA(:,3)=copulapdf('Frank',[U(:) V(:)],theta_old(3)); puz(:,1)=COPULA(:,1)*omega_old(1); puz(:,2)=COPULA(:,2)*omega_old(2); puz(:,3)=COPULA(:,3)*omega_old(3); for i=1:N puz1(i,1)=puz(i,1)/sum(puz(i,:)); puz1(i,2)=puz(i,2)/sum(puz(i,:)); puz1(i,3)=puz(i,3)/sum(puz(i,:)); end omega(1)=sum(puz1(:,1))/N; omega(2)=sum(puz1(:,2))/N; omega(3)=sum(puz1(:,3))/N; omega tt(:,1)=tinv(U(:),nuhat); tt(:,2)=tinv(V(:),nuhat); [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,theta_old,puz1,tt,nuhat); theta=turntheta; theta list1(:,count+1)=theta; list2(:,count+1)=omega; t=max([norm(theta_old(:)-theta(:));norm(omega_old(:)-omega(:))]) count=count+1end 参数更新（非线性优化bfgs）12345678910111213141516171819202122function [turntheta,fval,exitflag,output,grad,hessian]=updatetheta(N,U,V,theta,puz,t,nuhat)options=optimset('Display','iter-detailed','TolFun',1e-10,'TolX',1e-10,'LargeScale','off','FinDiffType','central','HessUpdate','bfgs');[turntheta,fval,exitflag,output,grad,hessian]=fminunc(@utheta,theta,options);function y=utheta(theta)if theta(3)==0 theta(3)=theta(3)+0.0001; %防止出现 Frank Copula 的相依结构参数为 0endy=0;th=eye(2);th(1,2)=theta(1);th(2,1)=theta(1);for j=1:N y=y+log(((det(th))^(-1/2))*gamma((nuhat+2)/2)*gamma(nuhat/2)*(1+t(j,:)*th^(-1)*t(j,:)'/nuhat)^(-(nuhat+2)/2)/((gamma((nuhat+1)/2))^2*((1+t(j,1)^2/nuhat)^(-(nuhat+1)/2)*(1+t(j,2)^2/nuhat)^(-(nuhat+1)/2))))*puz(j,1)+... log(exp(-((-log(U(j)))^theta(2)+(-log(V(j)))^theta(2))^(1/theta(2)))*(log(U(j))*log(V(j)))^(theta(2)-1)*(((-log(U(j)))^(theta(2))+(-log(V(j)))^(theta(2)))^(1/theta(2))+theta(2)-1)/(U(j)*V(j)*((-log(U(j)))^(theta(2))+(-log(V(j)))^(theta(2)))^(2-1/theta(2))))*puz(j,2)+... log(theta(3)*(1-exp(-theta(3)))*exp(-theta(3)*(U(j)+V(j)))/((1-exp(-theta(3)))-(1-exp(-theta(3)*U(j)))*(1-exp(-theta(3)*V(j))))^2)*puz(j,3);endy=-y;endend 结果 Copula函数 $\theta$ $\omega$ $k$ t-Copula 0.1244 0.0822 3 Gumbel-Copula 4.1127 0.7495 Frank-Copula 6.5931 0.1683 即$$C(u,v;a)=0.7495C{Gumbel}(u,v;4.1127)+0.1683C{Frank}(u,v;6.5931)+0.0822C_t(u,v;0.1244,3)$$ 结果评价Q-Q图可以与之前单一Copula的仿真QQ图进行比较可以明显的看出拟合优度上混合Copula有很大的优势 K-S检验 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ $K_M$ 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 0.0271 可以看出就K-S统计值而言混合Copula也小于其他单一Copula 欧式距离 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ $d_M$ 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 1.3220 可以看出就欧式距离而言混合Copula也小于其他单一Copula PS：作为一个学电气的人一开始看到要使用一个从未见过的EM算法我几乎是拒绝的，要多谢CS的室友和我分享了有关这方面的知识并且和我一起探讨。这个程序跑起来确实让人奔溃，跑一次就要三个多小时，但是最后仿真出来的结果符合我推测确实让我很开心]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[混合Copula函数风速建模——EM算法]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%B7%B7%E5%90%88Copula%E5%87%BD%E6%95%B0%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（5）——结果分析]]></title>
      <url>%2F2017%2F03%2F03%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%885%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Q-Q图分析 通过Q-Q图的判定原则可知，各类Copula函数差别不 很 明 显，其 中Gumbel-Copula，Frank-Copula，t-Copula函数曲线均较为接近45°曲线，拟合效果相对较好。以下采用统计法 K-S检验法 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ 桥湾，北大桥 0.0406 0.0395 0.0302 0.0520 0.0364 桥湾，干河口 0.0260 0.0219 0.0156 0.0489 0.0208 桥湾，昌马 0.0260 0.0239 0.0156 0.0499 0.0239 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 北大桥，昌马 0.0239 0.0239 0.0156 0.0385 0.0166 干河口，昌马 0.0208 0.0208 0.0146 0.0385 0.0156 通过K-S检验法的判定原则可知，在六种不同的风电场组合中，Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数的 $KS$ 统计值相对较小，而Normal-Copula，Clayton-Copula的统计值相对较大 秩相关性测度 数据来源 Kendall秩相关系数 $\tau$ Spearman秩相关系数 $\rho_s$ 原始观测数据 0.4816 0.6628 Normal-Copula 0.4371 0.6159 t-Copula 0.4410 0.6151 Gumbel-Copula 0.4604 0.6366 Clayton-Copula 0.2569 0.3751 Frank-Copula 0.4592 0.6465 通过与经验函数的Kendall秩相关系数，Spearman秩相关系数进行对比可以发现Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与原始数据保持着良好的秩相关性，而Normal-Copula，Clayton-Copula的秩相关性较差。 欧式距离 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ 桥湾，北大桥 2.8924 2.8209 1.3953 9.1763 2.4125 桥湾，干河口 2.7285 2.6970 1.1862 8.2528 2.2180 桥湾，昌马 2.3450 2.2558 1.3469 8.3662 1.8227 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 北大桥，昌马 1.7187 1.7470 1.5995 5.0238 1.3692 干河口，昌马 1.8369 1.8561 1.3731 4.8842 1.4301 可以看到在以上6种风电场组合中Gumbel-Copula，Frank-Copula，t-Copula这三种Copula函数与经验Copula函数的欧氏距离较小，而Normal-Copula，Clayton-Copula与经验函数的欧氏距离较大 结论任何一个单一的Copula函数都不能够非常好的表达风电场的相依结构，因此考虑使用混合Copula函数，即将表现较好的3个Copula函数进行加权组合，即$$C(u,v;a)=\omega1C{Gumbel}(u,v;\theta_1)+\omega2C{Frank}(u,v;\theta_2)+\omega_3C_t(u,v;\theta_3,k)$$ 其中 $\omega_1+ \omega_2+ \omega_3=1$]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关(4)——Copula模型评价]]></title>
      <url>%2F2017%2F03%2F02%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%884%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Q-Q图代码实现12345678910111213141516171819202122%计算网格点上Copula分布函数值画QQ图Ccdf_n=copulacdf('Gaussian',[Udata(:),Vdata(:)],rho_norm);Ccdf_t=copulacdf('t',[Udata(:),Vdata(:)],rho_t,nuhat);Ccdf_G=copulacdf('Gumbel',[Udata(:),Vdata(:)],paramhat_G);Ccdf_C=copulacdf('Clayton',[Udata(:),Vdata(:)],paramhat_C);Ccdf_F=copulacdf('Frank',[Udata(:),Vdata(:)],paramhat_F);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_n,size(Udata)),'b');xlabel('经验Copula');ylabel(['Normal Copula','rho:',num2str(rho_norm(1,2))]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Normal']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_t,size(Udata)),'b');xlabel('经验Copula');ylabel(['t-Copula','rho:',num2str(rho_t(1,2)),'k:',num2str(nuhat)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','t']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_G,size(Udata)),'b');xlabel('经验Copula');ylabel(['Gumbel-Copula','p_G:',num2str(paramhat_G)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Gumbel']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_C,size(Udata)),'b');xlabel('经验Copula');ylabel(['Clayton-Copula','p_C',num2str(paramhat_C)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Clayton']);figure;qqplot(reshape(CopulaEmpirical,size(Udata)),reshape(Ccdf_F,size(Udata)),'b');xlabel('经验Copula');ylabel(['Frank-Copula','p_F',num2str(paramhat_F)]); title([N&#123;n&#125;,'与',N&#123;m&#125;,'Q-Q图','Frank']); 结果 K-S检验以北大桥与桥湾风电场为例 代码实现123456%K-S检验[h_n,p_n,k_n]=kstest2(CopulaEmpirical',Ccdf_n)[h_t,p_t,k_t]=kstest2(CopulaEmpirical',Ccdf_t)[h_G,p_G,k_G]=kstest2(CopulaEmpirical',Ccdf_G)[h_C,p_C,k_C]=kstest2(CopulaEmpirical',Ccdf_C)[h_F,p_F,k_F]=kstest2(CopulaEmpirical',Ccdf_F) 结果 风电场组合 $k_N$ $k_t$ $k_G$ $k_C$ $k_F$ 桥湾，北大桥 0.0406 0.0395 0.0302 0.0520 0.0364 桥湾，干河口 0.0260 0.0219 0.0156 0.0489 0.0208 桥湾，昌马 0.0260 0.0239 0.0156 0.0499 0.0239 北大桥，干河口 0.0395 0.0343 0.0302 0.0468 0.0323 北大桥，昌马 0.0239 0.0239 0.0156 0.0385 0.0166 干河口，昌马 0.0208 0.0208 0.0146 0.0385 0.0156 Copula函数的秩相关性测度代码实现123456789101112131415%Copula模型的相关性测度%使用原始数据计算秩相关系数Kendall=corr([X,Y],'type','Kendall')Spearman=corr([X,Y],'type','Spearman')%计算Copula的秩相关系数Kendall_norm = copulastat('Gaussian',rho_norm)Spearman_norm = copulastat('Gaussian',rho_norm,'type','Spearman')Kendall_t = copulastat('t',rho_t,nuhat)Spearman_t = copulastat('t',rho_t,nuhat,'type','Spearman')Kendall_G = copulastat('Gumbel',paramhat_G)Spearman_G = copulastat('Gumbel',paramhat_G,'type','Spearman')Kendall_C = copulastat('Clayton',paramhat_C)Spearman_C = copulastat('Clayton',paramhat_C,'type','Spearman')Kendall_F = copulastat('Frank',paramhat_F)Spearman_F= copulastat('Frank',paramhat_F,'type','Spearman') 结果 数据来源 Kendall秩相关系数 $\tau$ Spearman秩相关系数 $\rho_s$ 原始观测数据 0.4816 0.6628 Normal-Copula 0.4371 0.6159 t-Copula 0.4410 0.6151 Gumbel-Copula 0.4604 0.6366 Clayton-Copula 0.2569 0.3751 Frank-Copula 0.4592 0.6465 欧式距离计算代码实现1234567891011121314151617181920%----------------求欧式距离% 通过循环计算经验Copula函数在新产生的网格点处的函数值CUV=zeros(size(UU(:)));for i=1:numel(UU) CUV(i)=C(UU(i),VV(i));end%求各Copula函数在原始样本点处的函数值Cnorm=copulacdf('Gaussian',[UU(:),VV(:)],rho_norm);Ct=copulacdf('t',[UU(:),VV(:)],rho_t,nuhat);CG=copulacdf('Gumbel',[UU(:),VV(:)],paramhat_G);CC=copulacdf('Clayton',[UU(:),VV(:)],paramhat_C);CF=copulacdf('Frank',[UU(:),VV(:)],paramhat_F);%计算欧式距离dnorm=sqrt((CUV-Cnorm)'*(CUV-Cnorm))dt=sqrt((CUV-Ct)'*(CUV-Ct))dG=sqrt((CUV-CG)'*(CUV-CG))dC=sqrt((CUV-CC)'*(CUV-CC))dF=sqrt((CUV-CF)'*(CUV-CF)) 结果 风电场组合 $d_N$ $d_t$ $d_G$ $d_C$ $d_F$ 桥湾，北大桥 2.8924 2.8209 1.3953 9.1763 2.4125 桥湾，干河口 2.7285 2.6970 1.1862 8.2528 2.2180 桥湾，昌马 2.3450 2.2558 1.3469 8.3662 1.8227 北大桥，干河口 3.6952 2.4590 1.6097 10.9923 1.6888 北大桥，昌马 1.7187 1.7470 1.5995 5.0238 1.3692 干河口，昌马 1.8369 1.8561 1.3731 4.8842 1.4301]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（3）——代码实现]]></title>
      <url>%2F2017%2F03%2F01%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%883%EF%BC%89%2F</url>
      <content type="text"><![CDATA[数据来源使用甘肃桥湾（1），北大桥（2），干河口（3），昌马（4）四处风速数据作为仿真数据 数据处理读入数据123456%从文件中读取数据load('data.mat');qw=data(:,1);%桥湾bdq=data(:,4);%北大桥ghk=data(:,7);%干河口cm=data(:,10);%昌马 对风速进行双参数威布尔分布化1234567891011121314151617181920%桥湾pqw=wblfit(qw);QW=wblpdf(1:50,pqw(1),pqw(2));QWC=wblcdf(qw,pqw(1),pqw(2));%北大桥pbdq=wblfit(bdq);BDQ=wblpdf(1:50,pbdq(1),pbdq(2));BDQC=wblcdf(bdq,pbdq(1),pbdq(2));%干河口pghk=wblfit(ghk);GHK=wblpdf(1:50,pghk(1),pghk(2));GHKC=wblcdf(ghk,pghk(1),pghk(2));%昌马pcm=wblfit(cm);CM=wblpdf(1:50,pcm(1),pcm(2));CMC=wblcdf(cm,pcm(1),pcm(2));d=&#123;qw,bdq,ghk,cm&#125;;D=&#123;QW,BDQ,GHK,CM&#125;;DD=&#123;QWC,BDQC,GHKC,CMC&#125;;N=&#123;'桥湾','北大桥','干河口','昌马'&#125;; 风电场 威布尔参数a 威布尔参数b 桥湾 8.1343 1.8773 北大桥 8.6619 1.7378 干河口 8.3685 1.5731 昌马 9.1261 2.1229 频率与频数直方图频率分布直方图12345678910111213141516171819202122232425262728293031323334353637383940%桥湾[fqw,qwc]=ecdf(qw);figure(1);ecdfhist(fqw,qwc,100);hold onplot(QW,'-r');title('桥湾');xlabel('风速');ylabel('f(x)');hold off%北大桥[fbdq,bdqc]=ecdf(bdq);figure(2);ecdfhist(fbdq,bdqc,100);hold onplot(BDQ,'-r');title('北大桥');xlabel('风速');ylabel('f(x)');hold off%干河口[fghk,ghkc]=ecdf(ghk);figure(3);ecdfhist(fghk,ghkc,100);hold on;plot(GHK,'-r');title('干河口');xlabel('风速');ylabel('f(x)');hold off%昌马[fcm,cmc]=ecdf(cm);figure(4);ecdfhist(fcm,cmc,100);hold onplot(CM,'-r');title('昌马');xlabel('风速');ylabel('f(x)');hold off 结果 频数分布直方图123456789for i=1:4 for j=i+1:4 figure; hist3([DD&#123;i&#125;(:) DD&#123;j&#125;(:)],[50,50]); xlabel(N&#123;i&#125;); ylabel(N&#123;j&#125;); zlabel('频数'); endend 结果 各Copula函数Copula函数参数估计12345rho_norm = copulafit('Gaussian',[U,V]);[rho_t,nuhat,nuci]=copulafit('t',[U,V]);paramhat_G=copulafit('Gumbel',[U,V]);paramhat_C=copulafit('Clayton',[U,V]);paramhat_F=copulafit('Frank',[U,V]); 结果 风电场组合 $\rho_{Norm}$ $\rho_t$ $k$ $\theta_G$ $\theta_C$ $\theta_F$ 桥湾与北大桥 0.6339 0.6386 9.1619 1.8533 0.6913 5.0402 桥湾与干河口 0.5346 0.5364 9.7829 1.6350 0.4847 3.8853 桥湾与昌马 0.6108 0.6169 10.4474 1.7697 0.6530 4.8459 北大桥与干河口 0.8092 0.8479 2.7192 2.9270 1.4685 9.8959 北大桥与昌马 0.3639 0.3630 33.9054 1.3098 0.3072 2.3697 干河口与昌马 0.3028 0.3026 21.9903 1.2628 0.2141 1.9736 经验Copula1234567891011121314%计算经验分布[fx,xsort]=ecdf(X);[fy,ysort]=ecdf(Y);%调用spine函数利用样条插值计算原始样本点的经验分布函数值UU=spline(xsort(2:end),fx(2:end),X);VV=spline(ysort(2:end),fy(2:end),Y);%定义经验Copula函数C=@(u,v)mean((UU&lt;=u).*(VV&lt;=v));[Udata,Vdata] = meshgrid(linspace(0,1,31));%循环计算经验Copula函数值for i=1:numel(Udata) CopulaEmpirical(i)=C(Udata(i),Vdata(i));end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（2）——函数性质以及常用代码]]></title>
      <url>%2F2017%2F02%2F28%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%882%EF%BC%89%2F</url>
      <content type="text"><![CDATA[1 二元Copula函数的定义以及性质定义: 二元Copula函数是指满足以下性质的函数$C(u,v)$: $C(u,v)$ 的定义域为[0,1]x[0,1]； $C(u,v)$ 有零基面，并且是二维递增的； 对任意$u,v\in [0,1]$，满足$C(u,1)=u，C(1,v)=v$。所谓的有零基面是：至少存在一个$u_0\in[0,1]$ 和一个$v_0\in[0,1]$，使得$C(u_0,v)=0=C(u,v_0)$。二维递增是指：对任意$0\le u_1\le u_2\le1$和$0\le v_1\le v_2\le1$，有$$C(u_2,v_2)-C(u_2,v_1)-C(u_1,v_2)+C(u_1,v_1)\ge 0$$ 性质： 二元Copula函数满足以下性质： $C(u,v)$ 关于每一个变量都是单调非减的 对于任意的$u,v\in[0,1],C(u,0)=C(0,v)=0,C(u,1)=u,C(1,v)=v$ 对任意$0\le u_1\le u_2\le1$和$0\le v_1\le v_2\le1$，有$$C(u_2,v_2)-C(u_2,v_1)-C(u_1,v_2)+C(u_1,v_1)\ge 0$$ 对任意的$u_1,u_2,v_1,v_2\in[0,1]$，有 $|C(u_2,v_2)-C(u_1,v_1)|\le|u_2-u_1|+|v_2-v_1|$。 对任意$u,v\in[0,1],max(u+v-1,0)\le C(u,v) \le min(u,v)$，令$C^-(u,v)=max(u+v-1,0),C^+(u,v)=min(u,v)$，则称$C^-(u,v)和 C^+(u,v)$ 分别为Frechet上界和下界 若$U,V$ 独立且同服从 $[0,1]$ 上的均匀分布，则$C(u,v)=uv$。 多元Copula函数的定义及性质定义： N元Copula函数是指满足以下性质的函数 $C(u_1,u_2,…,u_N)$ ： 定义域为 $[0,1]^N$ $C(u_1,u_2,…,u_N)$ 有零基面，并且是N维递增的； $C(u_1,u_2,…,u_N)$ 有边缘分布函数 $$ C_i(u_i)=C(1,…,1,u_i,1,…,1)=u_i $$ 其中 $u_i \in 0,1$ 。 性质： 多元Copula函数具备以下性质： $C(u_1,u_2,…,u_N)$ 关于每个变量都是单调非减得 $C(u_1,u_2,…,0,…,u_N)=0,C(1,…,1,u_i,1,…,1)=u_i$ 。 对任意的 $u_i,v_i \in 0,1$ ，有 $$|C(u_1,u_2,…,u_N)|-C(v_1,v_2,…,vN) \le {\displaystyle \sum {i=1}^N {|u_i-v_i|}}$$ 令 $C^-(u_1,u_2,…uN)=max({\displaystyle\sum{i=1}^N{u_i-N+1,0}})$ ，$C^+(u_1,u_2,…,u_N)=min(u_1,u_2,…,u_N)$ ，则对任意的 $u_i\in 0,1$ ，有 $$C^-(u_1,u_2,…u_N)\le C(u_1,u_2,…,u_N)\le C^+(u_1,u_2,…,u_N)$$ 记为 $C^-\prec C\prec C^+$ 。称 $C^-$ 和 $C^+$ 分别为Frechet上下界，当 $N\ge 2$ 时，$C^+$ 是一个N元Copula函数，但是当 $N&gt;2$ 时， $C^-$ 并不是一个Copula函数 若 $U_i\sim U(0,1)(i=1,2,…,N)$ 相互独立，则 $C(u_1,u_2,…,uN)={\displaystyle \prod {i=1}^N{u_i}}$ MATLAB常用Copula函数copulafit123456789%估计正态Copula中的参数1. RHOHAT=copulafit('Gaussian',U)%估计t-Copula中的参数2. [RHOHAT,nuhat]=copulafit('t',U)3. [RHOHAT,nuhat,nuci]=copulafit('t',U)%估计二元阿基米德Copula中的参数（包括Clayton，Frank，Gumbel）4. paramhat=copulafit(family,U)5. [paramhat,paramci]=copulafit(family,U)... copulastat12345678%计算正态Copula对应的Kendall秩相关系数1. R=copulastat('Gaussian',rho)%计算t-Copula对应的Kendall秩相关系数2. R=copulastat('t',rho,NU)%计算二元阿基米德Copula对应的Kendall秩相关系数（family字段可选Clayton，Frank，Gumbel）3. R=copulastat(family,alpha)%计算由type参数制定的秩相关系数R可选字段为'Kendall','Spearman'4. R=copulastat(...,'type',type) copulaparam根据秩相关系数求解Copula中的 $\rho$ 或 $\alpha$12345678%计算正态Copula中的线性相关参数ρ1. rho=copulaparam('Gaussian',R)%计算t-Copula中的线性相关参数ρ2. rho=copulaparam('t',R,NU)%计算二元阿基米德Copula中的参数α3. alpha=copulaparam(family,R)%用type参数指定秩相关系数的类型4. [...]=copulaparam(...,'type',type) copulapdf用于计算Copula的密度函数值1231. y = copulapdf('Gaussian',u,rho)2. y = copulapdf('t',u,rho,nu)3. y = copulapdf(family,u,alpha) copulacdf用于计算Copula分布函数值1231. y = copulacdf('Gaussian',u,rho)2. y = copulacdf('t',u,rho,nu)3. y = copulacdf(family,u,alpha) PS:双参数威布尔分布常用函数：wblfit,wblpdf,wblcdf Copula经验分布函数的求取123456789101112131415161718192021222324252627% 调用ecdf函数求X和Y的经验分布函数[fx, Xsort] = ecdf(X);[fy, Ysort] = ecdf(Y);% 调用spline函数，利用样条插值法求原始样本点处的经验分布函数值U = spline(Xsort(2:end),fx(2:end),X);V = spline(Ysort(2:end),fy(2:end),Y);% 定义经验Copula函数C(u,v)C = @(u,v)mean((U &lt;= u).*(V &lt;= v));% 为作图的需要，产生新的网格数据[Udata,Vdata] = meshgrid(linspace(0,1,31));% 通过循环计算经验Copula函数在新产生的网格点处的函数值for i=1:numel(Udata) CopulaEmpirical(i) = C(Udata(i),Vdata(i));endfigure; % 新建图形窗口% 绘制经验Copula分布函数图像surf(Udata,Vdata,reshape(CopulaEmpirical,size(Udata)))xlabel('U'); % 为X轴加标签ylabel('V'); % 为Y轴加标签zlabel('Empirical Copula C(u,v)'); % 为z轴加标签% 通过循环计算经验Copula函数在原始样本点处的函数值CUV = zeros(size(U(:)));for i=1:numel(U) CUV(i) = C(U(i),V(i));end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Copula风速建模相关（1）——相关参数]]></title>
      <url>%2F2017%2F02%2F27%2FCopula%E9%A3%8E%E9%80%9F%E5%BB%BA%E6%A8%A1%E7%9B%B8%E5%85%B3%EF%BC%881%EF%BC%89%2F</url>
      <content type="text"><![CDATA[Copula函数的拟合优度校验——与经验Copula函数对比 QQ图（Q-QNorm）把数据的分位数与已知分布相比较，从而来判断数据的分布情况。把已知分布的分位数标在纵轴上，样本分位数标在横轴上，从图形上可以了解到分布的信息。图形是直线说明是正态分布。图形中有一段是直线，在两端存在弧度，说明峰度的情况。 图形是曲线图，说明不对称。 如果Q-Q图是直线，当该直线成45度角并穿过原点时，说明分布与给定的正态分布完全一样。 如果是成45度角但不穿过原点，说明均值与给定的正态分布不同 如果是直线但不是45度角，说明均值与方差都与给定的分布不同。 如果Q-Q图中间部分是直线，但是右边在直线下面，左边在直线上面，说明分布的峰度大于3，反之说明峰度小于3. K-S检验法（Kolmogorov-Smirnov test）检验数据是否符合某种分布\Kolmogorov-Smirnov是比较一个频率分布f(x)与理论分布g(x)或者两个观测值分布的检验方法。其原假设H0:两个数据分布一致或者数据符合理论分布。 $D=max| f(x)- g(x)|$ ，当实际观测值D&gt;D(n,α)则拒绝H0，否则则接受H0假设。\KS检验与t-检验之类的其他方法不同是KS检验不需要知道数据的分布情况，可以算是一种非参数检验方法。当然这样方便的代价就是当检验的数据分布符合特定的分布事，KS检验的灵敏度没有相应的检验来的高。在样本量比较小的时候，KS检验最为非参数检验在分析两组数据之间是否不同时相当常用。\PS：t-检验的假设是检验的数据满足正态分布，否则对于小样本不满足正态分布的数据用t-检验就会造成较大的偏差，虽然对于大样本不满足正态分布的数据而言t-检验还是相当精确有效的手段。\本例中使用kstest2函数 对风电场风速进行处理——双参数威布尔分布双参数威布尔函数$$F_w(x)=1-exp(-({x \over c})^k)$$其概率密度函数为$$P(x)={k \over c} ({k \over c})^{k-1}exp(-({x \over c})^k)$$式中 $k$ 为形状参数，无量纲； $c$ 为尺度参数，反映风电场的平均风速，单位为 $m/s$ 。 Pearson相关系数简介皮尔逊相关也称为积差相关（或积矩相关）是英国统计学家皮尔逊于20世纪提出的一种计算直线相关的方法。在本例中主要用于对两组风速曲线的相关性进行表示 假设有两个变量X、Y，那么两变量间的皮尔逊相关系数可通过以下公式计算： 公式一： $$ \rho_{X,Y}={cov(X,Y) \over \sigma_X \sigma_Y}={E((X-\mu_X)(Y-\mu_Y))\over \sigma_X \sigma_Y}={E(XY)-E(X)E(Y)\over \sqrt{E(X^2)-E^2(X)}\sqrt{E(Y^2)-E^2(Y)}}$$ 公式二： $$\rho_{X,Y}={N\sum{XY}-\sum{X} \sum{Y} \over\sqrt{N\sum{X^2}-(\sum{X})^2}\sqrt{N\sum{Y^2}-(\sum{Y})^2}}$$ 公式三： $$\rho_{X,Y}={\sum(X-\overline{X})(Y-\overline{Y}) \over\sqrt{\sum(X-\overline{X})^2\sum(Y-\overline{Y})^2}}$$ 公式四： $$\rho_{X,Y}={\sum{XY}-{\sum{X}\sum{Y}\over N}\over\sqrt{(\sum{X^2}-{(\sum{X})^2\over N})}\sqrt{(\sum{Y^2}-{(\sum{Y})^2\over N})}}$$ 以上列出的四个公式等价，其中E是数学期望，cov表示协方差，N表示变量取值的个数。 适用范围当两个变量的标准差都不为零时，相关系数才有定义，皮尔逊相关系数适用于： 两个变量之间是线性关系，都是连续数据。 两个变量的总体是正态分布，或接近正态的单峰分布。 两个变量的观测值是成对的，每对观测值之间相互独立。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Copula理论的风电场间建模]]></title>
      <url>%2F2017%2F02%2F21%2F%E5%9F%BA%E4%BA%8ECopula%E7%90%86%E8%AE%BA%E7%9A%84%E9%A3%8E%E7%94%B5%E5%9C%BA%E9%97%B4%E5%BB%BA%E6%A8%A1%2F</url>
      <content type="text"><![CDATA[关于研究目的由于风电基地的多个风电场地理位置比较靠近，且基本处于同一风带，风速之间具有较强的相关性，使得多个风电场的总体特性不同于单个风电场的特性。 通过Copula理论进行多个风电场风俗的联合概率分布研究。 Copula理论关于Copula函数Copula函数在网络中所能检索到的信息 Copula函数百度Copula函数描述的是变量间的相关性，实际上是一类将联合分布函数与它们各自的边缘分布函数连接在一起的函数，因此也有人将它称为连接函数。相关理论的提出可以追溯到1959年，SKlar通过定理形式将多元分布与Copula函数联系起来。\20世纪90年代后期相关理论和方法在国外开始得到迅速发展并应用到金融，保险等领域的相关分析，投资组合分析和风险管理等多个方面。\定义:(Nelsen.2006) N 元Copula函数是指具有以下性质的函数（下记为C）：\（1）定义域为[0,1]×[0,1]×。。。×[0,1] （共为N个域相乘）；\（2）C具有零基面（grounded）且是N维递增的；\（3）C的边缘分布Cn，n=1,2,,,,N,满足Cn(xn)=C(1,…,1,xn,1,,,1)=xn，其中xn∈[0,1],n=1,2,,,N \ CopulaWIKI 123 要点： 边缘分布与联合分布的概念 关于风速的概率分布问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java第三次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass3%2F</url>
      <content type="text"><![CDATA[GUI设计 1. 框架123456789101112131415161718192021222324package AreaCalculate;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * Created by fatel on 2016/5/14. */public class CircleArea extends JFrame implements ActionListener&#123; public CircleArea()&#123; &#125; public void actionPerformed(ActionEvent ae)&#123; &#125; public static void main(String [] args)&#123; &#125;&#125; 2. 主界面12345CircleArea ca = new CircleArea();ca.setTitle("圆面积的计算");ca.setBounds(400,300,280,180);ca.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);ca.setVisible(true); 3. 搭建面板1234567891011121314JPanel p0 = new JPanel();JPanel p1 = new JPanel();JPanel p2 = new JPanel();JPanel p3 = new JPanel();JLabel l0 = new JLabel("圆面积计算系统", JLabel.CENTER);JLabel l1 = new JLabel("请输入圆的半径：", JLabel.CENTER);JLabel l2 = new JLabel("圆的面积是：", JLabel.CENTER);JTextField t1 = new JTextField(10);JTextField t2 = new JTextField(10);JButton b1 = new JButton("计算");JButton b2 = new JButton("清空"); 4. 面板布局123456789101112131415161718192021222324p1.setLayout(fl);p1.setBackground(Color.yellow);p1.add(l0);p2.setLayout(new GridLayout(2,2,5,5));p2.setBackground(Color.green);p2.add(l1);p2.add(t1);p2.add(l2);t2.setEditable(false);//t2不可编辑p2.add(t2);p3.setLayout(new FlowLayout(FlowLayout.CENTER, 5, 5));p3.setBackground(Color.pink);b1.addActionListener(this);b2.addActionListener(this);//添加监听器p3.add(b1);p3.add(b2);p0.add("North", p1);p0.add("Center", p2);p0.add("South", p3);this.setContentPane(p0); 5. 事件处理12345678public void actionPerformed(ActionEvent ae)&#123; if (ae.getSource()==b1)&#123; t2.setText(""+3.1415926*Double.parseDouble(t1.getText())*Double.parseDouble(t1.getText())); &#125;else&#123; t1.setText(""); t2.setText(""); &#125;&#125; 6. 代码优化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950JPanel []p = new JPanel[4];Color [] c = &#123;Color.red, Color.yellow, Color.green, Color.pink&#125;;LayoutManager [] lm = &#123; new BorderLayout(5,5), new FlowLayout(FlowLayout.CENTER, 5, 5), new GridLayout(2,2,5,5), new FlowLayout(FlowLayout.CENTER, 5, 5)&#125;;String [] str = &#123;"圆面积计算系统", "请输入圆的半径：", "圆的面积是："&#125;;JLabel [] l = new JLabel[3];JTextField [] t = new JTextField [2];String [] str1 = &#123;"计算", "清空"&#125;;JButton [] b = new JButton[2];public CircleArea()&#123; for (int i = 0;i &lt; p.length;i++)&#123; p[i] = new JPanel(lm[i]); p[i].setBackground(c[i]); &#125; for (int i = 0;i &lt; l.length;i++)&#123; l[i] = new JLabel(str[i], JLabel.CENTER); &#125; for (int i = 0;i &lt; t.length;i++)&#123; t[i] = new JTextField(10); &#125; for (int i = 0;i &lt; b.length;i++)&#123; b[i] = new JButton(str1[i]); b[i].addActionListener(this); p[3].add(b[i]); &#125; p[1].add(l[0]); p[2].add(l[1]); p[2].add(t[0]); p[2].add(l[2]); t[1].setEditable(false); p[2].add(t[1]); p[0].add("North", p[1]); p[0].add("Center", p[2]); p[0].add("South", p[3]); this.setContentPane(p[0]);&#125; 7. 异常处理###7.1 throw123456789public void actionPerformed(ActionEvent ae) throws NumberFormatException&#123; if (ae.getSource()==b[0])&#123; area=String.format("%5f", 3.1415926*Double.parseDouble(t[0].getText())*Double.parseDouble(t[0].getText())); t[1].setText(area); &#125;else&#123; t[0].setText(""); t[1].setText(""); &#125;&#125; 7.2 try catch123456789101112131415 public void actionPerformed(ActionEvent ae) throws NumberFormatException&#123; try&#123; if (ae.getSource()==b[0])&#123; area=String.format("%5f", 3.1415926*Double.parseDouble(t[0].getText())*Double.parseDouble(t[0].getText())); t[1].setText(area); &#125;else&#123; t[0].setText(""); t[1].setText(""); &#125; &#125; catch (NumberFormatException nfe)&#123; JOptionPane.showMessageDialog(null, nfe.getMessage(),"异常消息",JOptionPane.ERROR_MESSAGE); &#125;&#125; 7.3 异常类12345678910111213141516171819202122232425262728293031323334public void actionPerformed(ActionEvent ae) throws NumberFormatException &#123; try &#123; if (ae.getSource() == b[0]) &#123; if (t[0].getText().equals(""))&#123; throw new MyException("半径不能为空，请重新输入！！！"); &#125;else &#123; area = String.format("%5f", 3.1415926 * Double.parseDouble(t[0].getText()) * Double.parseDouble(t[0].getText())); t[1].setText(area); &#125; &#125; else &#123; t[0].setText(""); t[1].setText(""); &#125; &#125; catch (MyException me) &#123; JOptionPane.showMessageDialog(null, me.outExceMessage(), "异常消息", JOptionPane.ERROR_MESSAGE); &#125;catch (NumberFormatException nfe)&#123; JOptionPane.showMessageDialog(null, "输入不能为非数字，请重新输入", "异常消息", JOptionPane.ERROR_MESSAGE); t[0].setText(""); t[1].setText(""); &#125;&#125;class MyException extends NumberFormatException &#123; private String str; public MyException(String s) &#123; str = s; &#125; public String outExceMessage() &#123; return str; &#125;&#125;//类中类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 第二次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass2%2F</url>
      <content type="text"><![CDATA[封装继承多态 1. 父类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */class Robot &#123; protected String r_id; protected int speed; //private double temp; public Robot()&#123; r_id = JOptionPane.showInputDialog(null, "r_id = ", "请输入ID", JOptionPane.QUESTION_MESSAGE ); speed = Integer.parseInt( JOptionPane.showInputDialog(null, "speed = ", "请输入速度", JOptionPane.QUESTION_MESSAGE )); /*temp = Double.parseDouble(JOptionPane.showInputDialog(null, "temp = ", "请输入温度", JOptionPane.QUESTION_MESSAGE ));*/ &#125; public String judge()&#123; if (speed&gt;120)&#123; speed = 115; return "您超速了"; &#125;else&#123; //speed = 40; return "您的速度正常"; &#125; &#125; public void output()&#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = "+r_id+"\n"+"speed = "+speed +"\n" /*+ "temp = "+temp+"\n"*/+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; 2. 子类###2.1 子类1（WarRobot）1234567891011121314151617181920212223242526272829303132333435363738394041package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class WarRobot extends Robot &#123; private int weapon_count; //private String r_id; //private int speed; //private double temp; public WarRobot() &#123; super(); weapon_count = Integer.parseInt(JOptionPane.showInputDialog(null, "weapon_count = ", "请输入武器数量", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge() &#123; if (weapon_count &gt; 10) &#123; speed = 200; return "您是战神"; &#125; else &#123; //speed = 40; return "您是菜鸟"; &#125; &#125; public void output() &#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = " + r_id + "\n" + "speed = " + speed + "\n" + "weapon_count = " + weapon_count + "\n" + judge() + "\n", "战斗机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; ###2.2 子类2（HomeRobot）123456789101112131415161718192021222324252627282930313233343536373839404142package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class HomeRobot extends Robot&#123; private int skill_count; //protected String r_id; //protected int speed; //private double temp; public HomeRobot()&#123; super(); skill_count = Integer.parseInt(JOptionPane.showInputDialog(null, "skill_count = ", "请输入技能数", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge()&#123; if (skill_count&gt;5)&#123; // speed = 115; return "你是家务大师"; &#125;else&#123; //speed = 40; return "您是家务菜鸟"; &#125; &#125; public void output()&#123; super.output(); JOptionPane.showMessageDialog(null,//父容器 "skill_count = "+skill_count+"\n"+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125;&#125; ###2.3 UML类图 #抽象类 ##1. 父类抽象类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */abstract class Robot &#123; protected String r_id; protected int speed; //private double temp; public Robot()&#123; r_id = JOptionPane.showInputDialog(null, "r_id = ", "请输入ID", JOptionPane.QUESTION_MESSAGE ); speed = Integer.parseInt( JOptionPane.showInputDialog(null, "speed = ", "请输入速度", JOptionPane.QUESTION_MESSAGE )); /*temp = Double.parseDouble(JOptionPane.showInputDialog(null, "temp = ", "请输入温度", JOptionPane.QUESTION_MESSAGE ));*/ &#125; public String judge()&#123; if (speed&gt;120)&#123; speed = 115; return "您超速了"; &#125;else&#123; //speed = 40; return "您的速度正常"; &#125; &#125; public void output()&#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = "+r_id+"\n"+"speed = "+speed +"\n" /*+ "temp = "+temp+"\n"*/+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); public void abstract run(); &#125;&#125; ##2.子类 ###2.1 子类11234567891011121314151617181920212223242526272829303132333435363738394041424344package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class WarRobot extends Robot &#123; private int weapon_count; //private String r_id; //private int speed; //private double temp; public WarRobot() &#123; super(); weapon_count = Integer.parseInt(JOptionPane.showInputDialog(null, "weapon_count = ", "请输入武器数量", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge() &#123; if (weapon_count &gt; 10) &#123; speed = 200; return "您是战神"; &#125; else &#123; //speed = 40; return "您是菜鸟"; &#125; &#125; public void output() &#123; JOptionPane.showMessageDialog(null,//父容器 "r_id = " + r_id + "\n" + "speed = " + speed + "\n" + "weapon_count = " + weapon_count + "\n" + judge() + "\n", "战斗机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125; public void run()&#123; System.out.println("我像风一样的奔跑"); &#125;&#125; ###2.2 子类2（HomeRobot）123456789101112131415161718192021222324252627282930313233343536373839404142434445package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */ class HomeRobot extends Robot&#123; private int skill_count; //protected String r_id; //protected int speed; //private double temp; public HomeRobot()&#123; super(); skill_count = Integer.parseInt(JOptionPane.showInputDialog(null, "skill_count = ", "请输入技能数", JOptionPane.QUESTION_MESSAGE )); &#125; public String judge()&#123; if (skill_count&gt;5)&#123; // speed = 115; return "你是家务大师"; &#125;else&#123; //speed = 40; return "您是家务菜鸟"; &#125; &#125; public void output()&#123; super.output(); JOptionPane.showMessageDialog(null,//父容器 "skill_count = "+skill_count+"\n"+ judge() + "\n", "机器人信息", JOptionPane.INFORMATION_MESSAGE ); &#125; public void run()&#123; System.out.println("我像仙女一样在飘"); &#125;&#125; ##3. 运行程序123456789101112131415161718192021222324252627282930package Class_1;import javax.swing.*;/** * Created by fatel on 2016/5/8. */public class MainProg&#123; public static void main (String [] args)&#123;// 命令行运行输入的参数 Robot r1;//为超类Robot新建一个引用 WarRobot wr = new WarRobot(); wr.output(); HomeRobot hr = new HomeRobot(); hr.output(); //将超类Robot的引用r1指向子类WarRobot的对象wr r1 = wr; r1.run(); r1 = hr; r1.run(); //Robot r1 = new WarRobot(); &#125;&#125; #接口 ##1. 接口123456package Program;public interface Robot &#123; public final int SPEED=100; public abstract void walk();&#125; 123456package Program;public interface MusicRobot &#123; public final int PLAY_KINDS=10; public abstract void play();&#125; 123456package Program;public interface WarRobot extends Robot&#123; public final int WEAPON_COUNT=15; public abstract void war();&#125; 123456package Program;public interface HomeRobot extends Robot&#123; public final int SKILL_COUNT=8; public abstract void cook();&#125; ##2. 子类1234567891011121314151617181920212223242526272829303132333435363738394041424344package Program;public class SuperRobot implements HomeRobot,WarRobot,MusicRobot&#123; private String id; private int SuperAbility; public SuperRobot(String i,int s)&#123; id=i; SuperAbility=s; &#125; public void judge()&#123; if (SuperAbility&gt;120)&#123; System.out.println("您太厉害了"); &#125; else&#123; System.out.println("您还需要继续修炼"); &#125; &#125; public void cook() &#123; // TODO Auto-generated method stub System.out.println("I can cook!"); &#125; public void walk() &#123; // TODO Auto-generated method stub System.out.println("I can walk!"); &#125; public void war() &#123; // TODO Auto-generated method stub System.out.println("I can war!"); &#125; public void play() &#123; // TODO Auto-generated method stub System.out.println("I can play instruments!"); &#125; public void output()&#123; System.out.println("id="+id+"\nSuperAbility="+SuperAbility); &#125;&#125; ##3. 执行程序12345678910111213141516171819package Program;public class MainProgram &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub SuperRobot r=new SuperRobot("r001",10); r.judge(); r.walk(); r.war(); r.cook(); r.play(); r.output(); &#125;&#125; ##4. UML图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java第四次课]]></title>
      <url>%2F2016%2F10%2F23%2Fjavaclass4%2F</url>
      <content type="text"><![CDATA[1. 基础面板搭建 12345678910111213141516171819202122232425262728293031package mygame;import javax.swing.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;/** * Created by fatel on 2016/5/28. */public class CartoonApp extends JFrame implements ActionListener&#123; public CartoonApp()&#123; &#125; @Override public void actionPerformed(ActionEvent e) &#123; &#125; class CartoonPaint extends JPanel&#123; &#125; public static void main (String [] args)&#123; CartoonApp ca = new CartoonApp(); ca.setTitle("我的第一个动画程序"); ca.setBounds(300,200,400,450); ca.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); ca.setVisible(true); &#125;&#125; 2. 变量定义123456789101112JPanel [] pnl = &#123;new JPanel(new BorderLayout()), new JPanel(new FlowLayout()), new JPanel(new BorderLayout()), new JPanel(new FlowLayout())&#125;; String [] str = &#123;"North", "Center", "South"&#125;; JLabel lblTitle = new JLabel("我的第一个动画程序"); JButton [] btn = &#123;new JButton("start"), new JButton("pause"), new JButton("resume"), new JButton("exit")&#125;; int x,y,z; Random rnd = new Random(); Color [] c = &#123;Color.red, Color.green, Color.blue,Color.pink, Color.yellow&#125;; CartoonPaint cp = new CartoonPaint(); 3.基本图形绘制123456789101112class CartoonPaint extends JPanel&#123; public void paintComponent(Graphics g)&#123; g.setColor(c[0]); g.drawOval(10,10,100,100); g.fillOval(120,10,100,100); g.drawRect(230,10,100,100); g.fillRect(340,10,100,100); int [] x1 = &#123;100, 50,150&#125;; int [] y1 = &#123;50,150, 150&#125;; g.drawPolygon(new Polygon(x1,y1,x1.length)); &#125; &#125; 4. 异常123456789101112131415public void actionPerformed(ActionEvent ae) &#123; try&#123; if (ae.getSource()==btn[0])&#123; &#125;else if (ae.getSource()==btn[1])&#123; &#125;else if (ae.getSource()==btn[2])&#123; &#125;else if (ae.getSource()==btn[3])&#123; System.exit(0); &#125; &#125;catch(Exception ex)&#123; JOptionPane.showMessageDialog(null,ex.getMessage()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[可延迟负荷控制]]></title>
      <url>%2F2016%2F07%2F06%2F%E5%8F%AF%E5%BB%B6%E8%BF%9F%E8%B4%9F%E8%8D%B7%E6%8E%A7%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Notes of Real-time deferrable load control: handling the uncertainties of renewable generation简介 趋势：传统的煤炭、核能等发电能源逐渐被可再生能源所取代 可再生能源的不规律、不可预测性给控制带来了很多麻烦 需求响应：引导用户的动态电力负载需求管理与电力供应情况相匹配，可以弥补可再生能源的不确定性造成的影响 deferrable load：可以推迟一段时间再执行，可以通过推迟负荷时间来与可再生能源的供给匹配 要点：分散式直接负荷控制 总结 提供了一个考虑未来时间段的负载与可再生能源状态预测的实时分布式可延迟负载控制算法 建模给可延迟负载排了时间表 一个有限时间域里的离散时间模型（一天，十分钟为间隔） 可再生能源与非可延迟负载非可延时负载在低聚程度上很难有效预测将可再生能源发电机与非可延时类负载聚合到一个进程——基础负载是非可延迟负载与可再生能源之间的误差滤波器？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于柔性建模]]></title>
      <url>%2F2016%2F07%2F05%2Fflexibility%2F</url>
      <content type="text"><![CDATA[智能电网柔性成分运行建模方法研究研究可调负荷和储能的运行特性，并建立其运行模型；研究柔性成分与可再生能源联合运行方式；仿真模拟可调负荷和储能运行的减排效果，验证所建模型有效性。 存在大量的DER（分布式能源），其潜在的供需调节能力尚未被完全开发和利用： 电――化学类：钠硫电站、电动汽车、充换电站、气电转换。 电――热转换类: 空调、地暖、电热水器、蓄热、蓄冷、蓄冰等，调节特性受热力/耗散方程的约束。 纯电类需求响应：通过工作时间的调整响应电力波动，实现供需两侧之间的缓冲调节功能（类储能功能）。e.g:洗衣机、洗碗机、etc. 基本描述：参与方申报可承受功率曲线范围、服务的最早开始时间和能量水平、最晚结束（完成）时间和能量水平、可承受价格范围、最大可中断次数等。云服务器端进行在线优化、实时结算和价格发布。 实现虚拟储能网的关键技术――1、设备间的统一通讯标准和规约、即插即识别即用、智能家居；2、电力传输网络的建模，阻塞与网损管理；3、有效的电价信号、激励机制和商业模式；4、对设备和其拥有者信息的有效保护。 研究内容：1、DER的统一建模；2、电力传输网络的建模；3、信息安全；4、电价设计；5、实施效果的检验与仿真；6、现场测试。 项目成效及应用前景：1、调峰效果；2、延缓输配电系统投资的效果（线路、变压器、线路）；3、运行效益（网损、运维、检修灵活性）；4、促进随机间歇性可再生能源消纳与碳减排效果；5、社会效益。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[notes]]></title>
      <url>%2F2016%2F07%2F05%2Fnotes%2F</url>
      <content type="text"><![CDATA[Notes about Large-scale integration of deferrable demand and renewable energy sources ABSTRACT stochastic unit commitment model 随机机组组合模型 ？ [ ]deferrable demand in power system 电力系统中的可暂缓需求（可调性需求？） [x]reserve requirements 储能需求 [ ]the benefits of demand flexibility 需求弹性收益 ？ [x]three demand response paradigms 三个需求响应的样例 [ ]the centralized co-optimization of generation 发电的集中联合优化 ？ [x]demand by the system operator, demand bids 来自于系统操作人员和订单的需求 [ ]the coupling of renewable resources with deferrable loads 可再生能源与可调性负载的耦合 ？ [ ]motivate coupling as an alternative for overcoming the drawbacks of the two alternative demand response options 将耦合作为克服另外两个需求响应缺点的替代选项 [x]a dynamic programming algorithm for coordinating deferrable demand with renewable supply 一个用于协调可调性需求与可再生能源供给的动态算法 [ ]simulation results for a model of the Western Electricity Coordinating Council 关于西部电力协调理事会的模型仿真结果 [ ]load management 负载管理 [ ]power generation scheduling 电力发电规划 [ ]wind power generation 风力发电 INTRODUCTION high variability, unpredictable fluctuation, a limited control of output与传统发电方式相比，可再生能源的关键缺陷在于它的高变化性，波动不可预测和输出仅在有限范围内可控 demand response需求响应对于大规模的可再生能源是很有好处的 represent the balancing operations of the remaining grid by using a unit commitment model用一个机组组合模型来表示当前电网的平衡措施来评估可再生能源与需求响应的影响 doesn’t model the deferrable nature of various of various demand response or account for the uncertainty that is introduced by the large-scale integration of renewable resources以往这个领域的研究没有就变化的需求响应的可调性特征建模，也没有考虑由大规模可再生能源导致的不确定性 economic dispatch model经济调度模型 explore the direct coupling of deferrable consumers with renewable resources into a virtual resource through a contractual agreement based on a strike price that limits the impact of the coupled system on the rest of the network探索了在限制耦合系统对于网络其他部分的影响的成交价下将可调性负载与可再生能源直接耦合接入虚拟。。。（不是很懂） Literature Review high investment cost of backup reserves后备储能设施的投入来保证系统的可靠操作 quantifying reserve requirements as well as the impacts of renewable integration on operating costs定量储藏要求和可再生能源对于运行损耗的影响 impact of renewable supply uncertainty on power system operations (focus)可再生能源供应的不确定性对电力系统操作的影响 the potential benefits of demand response integration一体化需求响应的潜在好处 ？ demand function需求函数 However, many flexible consumption tasks are best characterized as deferrable, in the sense that consumers need a certain amount of energy within a certain time window. As such, deferrable demand behaves much like a hydro or storage resource from the view point of the system operator. Electric vehicle charging, agricultural pumping, pre-cooling, and residential consumption such as laundry fit this characterization.为什么更像一个水电或者储存？农业泵，洗衣机为什么相似？ real-time pricing at the retail level需要实时电价 volatility of wholesale electricity prices批发电价的波动性 the non-convex) costs of system operations实时电价由于系统运行中的非凸成本（有绝对的需求时）不能表达出需求响应的经济价值 为什么是非凸的？ excessive startup and minimum load costs上述问题会导致过多的启动和最小负载成本 the system operator dispatches the system at a bulk scale and cannot control individual retail loads只能在大规模上，不能分布式 concerns about defining market products that correspond to the types of services that loads can actually offer, which raises the need for reform in existing electricity markets需要对现有市场进行改革 Paper Contributions a stochastic unit commitment model that can be used in order to quantify the benefits of deferrable demand in mitigating the increased operating costs and day-ahead reserve requirements resulting from the random fluctuation of renewable energy supply一个可以用来量化可延缓需求在减少增长的运行损耗和由于可再生能源的随机波动导致的提前一天的存储需求 The use of stochastic planning models for simulating long-term market equilibrium in order to quantify generation investment in the face of long-term uncertainty用随机规划模型来模拟长期市场均衡以用来量化面对长期不确定性情况下的发电投资 used in order to simulate the two-stage operation of day-ahead and real-time electricity markets用来模拟提前一天的二阶操作和实时的电力市场 computational challenges using an appropriate scenario selection technique to discretize the uncertainty space of the problem extend existing models by simultaneously modeling the inter-temporal dependency of deferrable demand and renewable supply uncertainty跨时间段的依赖关系和可再生能源供给的随机性 present a contractual alternative for coupling the operations of renewable resources with deferrable demand that attempts to overcome the implementation barriers associated with centralized load dispatch and real-time pricing of retail loads, and compare the relative performance of each demand response paradigm in terms of system operating costs展现了一个（（具备试图克服执行障碍和集中负载调度的可调需求的可再生资源的操作）与（基于零售负载的实时电价的耦合））的基于合同的替代选项，并且比较了在系统运行损耗中各个不同的需求响应模式的表现 MODEL OVERVIEW Uncertainty in the model is driven by renewable supply and demand. Demand resources in the system are categorized as inflexible (firm) consumers with stochastic consumption patterns and deferrable consumers that require a fixed amount of energy within the day and adapt their instantaneous consumption patterns to the prevailing system conditions.把需求分为了两类，一类是固定用户，消耗模式随机，另一类是可调用户，需求固定，消耗模式适配到系统即时状态 The decision support module in the upper portion of the figure simulates day-ahead market operations and is used for determining day-ahead reserve requirements when deferrable demand contributes to absorbing the variability of renewable energy supply The evaluation module in the lower portion of the figure uses the reserves committed by the day-ahead model in order to compare the real-time operating costs of the system under the three demand response paradigms that are discussed in the introduction of the paper. Statistical Models We use a second order autoregressive model for modeling demand and load.二阶自回归模型用来模拟需求和负载 固定需求与可再生能源产出是相互独立的（assumption） employ a data set published by NREL which provides time series of wind speed at various geographic locations over a year Yule-Walker equationsProbability distribution function of inflexible demand In the present analysis we use a single-area wind model and ignore transmission constraints in order to focus on the impact of demand response.在现在的分析中，我们使用了单个区域的风力模型并且为了集中于需求响应忽略了传递约束 （没做多个区域和考虑传递约束的） The problem of balancing the schedules of coupled resources with the rest of the system while respecting transmission constraints would be addressed by the system operator and would be reflected in locational marginal prices from the point of view of aggregators.在考虑传递约束的情况下，平衡耦合资源规划与系统其他部分的问题会有系统操作员来解决，并且从聚合的角度来看 ？，这个结果会反映在节点边际电价上 the aggregator can hedge by buying financial transmission rights？ 购买输电权。。对冲 Stochastic Unit Commitment assumes that the system operator co-optimizes the dispatch of flexible loads and generation resources假设系统操作员可以同时协调控制柔性负载与发电资源 two-stage decision model where the first stage represents day-ahead unit commitment and the second stage represents real-time economic dispatch in the hour-ahead market, in hourly intervals, subsequent to the realization of uncertainty一个第一阶段表示日超前机组组合模型第二阶段表示由于不确定性的实现因而以一小时为间隔的时超前市场上的实时经济调度的二阶决策模型 操作员每小时能够计算出模型结果是基础 $S$ a discrete set of scenarios$G$ set of gengrators$G_s$ set of slow generators which commitment decisions are fixed in the day-ahead time frame $G_s\in G$, another part are fast generators that can adjust their commitment schedule in the second stage$w_{gt}$ First-stage decisions$z_{gt}$ the binary unit commitment and startup decisions for slow generators$u_{gst}$ the unit commitment of all generators$v_{gst}$ startup of all generators$p_{gst}$ power output of all generators$e_{st}$ The dispatch of deferrable loads (a second-stage decision variable)$S_{g}$ startup cost for each generator$K_g$ minimun load costs for each generator$C_g$ constant fuel costs for each generator$D_{st}$ net demand (the net of firm demand minus renewable power supply, represents the source of uncertainty)$\mathcal{D}$ includes generator capacity constraints, ramping constraints, and minimum up and down times, where bold fonts indicate vectors. The objective function of (1) minimizes operating costs. Power balance is enforced in (2). The constraint of (3) requires that deferrable loads be supplied an amount of energy within a given time window. (4) enforces a limit of on the consumption (e.g., charge) rate of deferrable loads. The non-anticipativity constraints on first-stage decisions is enforced in (5). all generators, including slow units, can adjust their production level in the second stage The solution of the stochastic unit commitment model is described in detail by Papavasiliou [37] About scenario selection algorithm scenarios are selected according to their effect on expected cost and weighed such that their selection does not bias the objective function of the stochastic unit commitment formulation场景是根据他们各自对于期望损耗的效果来权衡保证选择与随机机组组合模型的目标函数无关 The decomposition algorithm which is employed relies on a Lagrangian relaxation scheme for scenario decomposition.分解算法基于拉格朗日松弛算法 The centralized stochastic unit commitment model presented in this section presumes the ability of the system operator to centrally monitor and control individual loads.]]></content>
    </entry>

    
  
  
</search>
